#!/usr/bin/env bash

set -eu

msgdebug=false
nocolor=false
debug=false
pacman_args=""
operation="none"

wfa_version="0.1"

# メッセージ出力の制御
# https://github.com/FascodeNet/alterlinux/blob/dev/tools/msg.sh の変数名にアンダーバーを追加し関数化
msg() {
    local OPTIND OPTARG arg

    local _appname="msg.sh"
    local _bash_debug=false
    local _nocolor=false
    local _echo_opts=""
    local _message=""
    local _msg_type="info"
    local _msg_label=""
    local _label_space="7"
    local _adjust_chr=" "
    local _customized_label=false
    local _customized_label_color=false
    local _nolabel=false
    local _noappname=false
    local _noadjust=false
    local _output="stdout"

    _help() {
        echo "usage ${0} [option] [type] [message]"
        echo
        echo "Display a message with a colored app name and message type label"
        echo
        echo " General type:"
        echo "    info                      General message"
        echo "    warn                      Warning message"
        echo "    error                     Error message"
        echo "    debug                     Debug message"
        echo
        echo " General options:"
        echo "    -a [name]                 Specify the app name"
        echo "    -c [character]            Specify the character to adjust the label"
        echo "    -l [label]                Specify the label."
        echo "    -n | --nocolor            No output colored output"
        echo "    -o [option]               Specify echo options"
        echo "    -r [color]                Specify the color of label"
        echo "    -s [number]               Specifies the label space."
        echo "    -x | --bash-debug         Enables output bash debugging"
        echo "    -h | --help               This help message"
        echo
        echo "         --nolabel            Do not output label"
        echo "         --noappname          Do not output app name"
        echo "         --noadjust           Do not adjust the width of the label"
    }

    while getopts "a:c:l:no:r:s:xh-:" arg; do
        case ${arg} in
                a) 
                    _appname="${OPTARG}"
                    ;;
                c) 
                    _adjust_chr="${OPTARG}"
                    ;;
                l) 
                    _customized_label=true
                    _msg_label="${OPTARG}"
                    ;;
                n)
                    _nocolor=true
                    ;;
                o)
                    _echo_opts="${OPTARG}"
                    ;;
                r)
                    _customized_label_color=true
                    case ${OPTARG} in
                        "black")
                            _labelcolor="30"
                            ;;
                        "red")
                            _labelcolor="31"
                            ;;
                        "green")
                            _labelcolor="32"
                            ;;
                        "yellow")
                            _labelcolor="33"
                            ;;
                        "blue")
                            _labelcolor="34"
                            ;;
                        "magenta")
                            _labelcolor="35"
                            ;;
                        "cyan")
                            _labelcolor="36"
                            ;;
                        "white")
                            _labelcolor="37"
                            ;;
                        *)
                            return 1
                            ;;
                    esac
                    ;;
                s)
                    _label_space="${OPTARG}"
                    ;;
                x)
                    _bash_debug=true
                    set -xv
                    ;;
                h)
                    _help
                    shift 1
                    exit 0
                    ;;
                -)
                    case "${OPTARG}" in
                        "nocolor")
                            _nocolor=true
                            ;;
                        "bash-debug")
                            _bash_debug=true
                            set -xv
                            ;;
                        "help") 
                            _help
                            exit 0
                            ;;
                        "nolabel")
                            _nolabel=true
                            ;;
                        "noappname")
                            _noappname=true
                            ;;
                        "noadjust")
                            _noadjust=true 
                            ;;
                        *)
                            _help
                            exit 1
                            ;;
                    esac
        esac
    done

    shift $((OPTIND - 1))

    # Color echo
    #
    # Text Color
    # 30 => Black
    # 31 => Red
    # 32 => Green
    # 33 => Yellow
    # 34 => Blue
    # 35 => Magenta
    # 36 => Cyan
    # 37 => White
    #
    # Background color
    # 40 => Black
    # 41 => Red
    # 42 => Green
    # 43 => Yellow
    # 44 => Blue
    # 45 => Magenta
    # 46 => Cyan
    # 47 => White
    #
    # Text decoration
    # You can specify multiple decorations with ;.
    # 0 => All attributs off (ノーマル)
    # 1 => Bold on (太字)
    # 4 => Underscore (下線)
    # 5 => Blink on (点滅)
    # 7 => Reverse video on (色反転)
    # 8 => Concealed on

    case ${1} in
        "info")
            _msg_type="type"
            _output="stdout"
            [[ "${_customized_label_color}" = false ]] && _labelcolor="32"
            [[ "${_customized_label}"       = false ]] && _msg_label="Info"
            shift 1
            ;;
        "warn")
            _msg_type="warn"
            _output="stdout"
            [[ "${_customized_label_color}" = false ]] && _labelcolor="33"
            [[ "${_customized_label}"       = false ]] && _msg_label="Warning"
            shift 1
            ;;
        "debug")
            _msg_type="debug"
            _output="stdout"
            [[ "${_customized_label_color}" = false ]] && _labelcolor="35"
            [[ "${_customized_label}"       = false ]] && _msg_label="Debug"
            shift 1
            ;;
        "error")
            _msg_type="error"
            _output="stderr"
            [[ "${_customized_label_color}" = false ]] && _labelcolor="31"
            [[ "${_customized_label}"       = false ]] && _msg_label="Error"
            shift 1
            ;;
        "")
            echo "Please specify the message type" >&2
            exit 1
            ;;
        *)
            echo "Unknown message type" >&2
            exit 1
            ;;
    esac

    _word_count="${#_msg_label}"
    _message="${@}"

    echo_type() {
        local __time
        if [[ "${_nolabel}" = false ]]; then
            if [[ "${_noadjust}" = false ]]; then
                for __time in $( seq 1 $(( ${_label_space} - ${_word_count})) ); do
                    echo -ne "${_adjust_chr}"
                done
            fi
            if [[ "${_nocolor}" = false ]]; then
                echo -ne "\e[$([[ -v _backcolor ]] && echo -n "${_backcolor}"; [[ -v _labelcolor ]] && echo -n ";${_labelcolor}"; [[ -v _decotypes ]] && echo -n ";${_decotypes}")m${_msg_label}\e[m "
            else
                echo -ne "${_msg_label} "
            fi
        fi
    }

    echo_appname() {
        if [[ "${_noappname}" = false ]]; then
            if [[ "${_nocolor}" = false ]]; then
                echo -ne "\e[36m[${_appname}]\e[m "
            else
                echo -ne "[${_appname}] "
            fi
        fi
    }

    for _count in $(seq "1" "$(echo -ne "${_message}\n" | wc -l)"); do
        _echo_message=$(echo -ne "${_message}\n" |head -n "${_count}" | tail -n 1 )
        _full_message="$(echo_appname)$(echo_type)${_echo_message}"
        case "${_output}" in
            "stdout")
                echo ${_echo_opts} "${_full_message}" >&1
                ;;
            "stderr")
                echo ${_echo_opts} "${_full_message}" >&2
                ;;
            *)
                echo ${_echo_opts} "${_full_message}" > ${_output}
                ;;
        esac
    done
}

# Show an INFO message
# $1: message string
msg_info() {
    local _msg_opts="-a WFA"
    if [[ "${1}" = "-n" ]]; then
        _msg_opts="${_msg_opts} -o -n"
        shift 1
    fi
    [[ "${msgdebug}" = true ]] && _msg_opts="${_msg_opts} -x"
    [[ "${nocolor}"  = true ]] && _msg_opts="${_msg_opts} -n"
    msg ${_msg_opts} info "${1}"
}

# Show an Warning message
# $1: message string
msg_warn() {
    local _msg_opts="-a WFA"
    if [[ "${1}" = "-n" ]]; then
        _msg_opts="${_msg_opts} -o -n"
        shift 1
    fi
    [[ "${msgdebug}" = true ]] && _msg_opts="${_msg_opts} -x"
    [[ "${nocolor}"  = true ]] && _msg_opts="${_msg_opts} -n"
    msg ${_msg_opts} warn "${1}"
}

# Show an debug message
# $1: message string
msg_debug() {
    if [[ "${debug}" = true ]]; then
        local _msg_opts="-a WFA"
        if [[ "${1}" = "-n" ]]; then
            _msg_opts="${_msg_opts} -o -n"
            shift 1
        fi
        [[ "${msgdebug}" = true ]] && _msg_opts="${_msg_opts} -x"
        [[ "${nocolor}"  = true ]] && _msg_opts="${_msg_opts} -n"
        msg ${_msg_opts} debug "${1}"
    fi
}

# Show an ERROR message then exit with status
# $1: message string
# $2: exit code number (with 0 does not exit)
msg_error() {
    local _msg_opts="-a WFA"
    if [[ "${1}" = "-n" ]]; then
        _msg_opts="${_msg_opts} -o -n"
        shift 1
    fi
    [[ "${msgdebug}" = true ]] && _msg_opts="${_msg_opts} -x"
    [[ "${nocolor}"  = true ]] && _msg_opts="${_msg_opts} -n"
    msg ${_msg_opts} error "${1}"
    if [[ -n "${2:-}" ]]; then
        exit ${2}
    fi
}

usage (){
    local _wfa_usage
    _wfa_usage() {
        echo "Usage:"
        echo "wfa"
        echo "wfa <operation> [...]"
        echo
        echo "operations:"
        echo "wfa {-h --help}"
        echo "wfa {-V --version}"
        #echo "wfa {-D --database}    <options> <package(s)>"
        #echo "wfa {-F --files}       [options] [package(s)]"
        echo "wfa {-Q --query}       [options] [package(s)]"
        echo "wfa {-R --remove}      [options] <package(s)>"
        echo "wfa {-S --sync}        [options] [package(s)]"
        #echo "wfa {-T --deptest}     [options] [package(s)]"
        #echo "wfa {-U --upgrade}     [options] <file(s)>"
    }

    if [[ "${operation}" = "none" ]]; then
        _wfa_usage
    else
        pacman -h --${operation}
    fi
}

set_operation() {
    if [[ "${operation}" = "none" ]]; then
        operation="${1}"
        add_pacman_args "--${operation}"
    else
        msg_error "only one operation may be used at a time" 1
    fi
}

run_sudo() {
    if (( ${UID} == 0 )); then
        ${@}
    else
        sudo ${@}
    fi
}

run_pacman() {
    run_sudo pacman ${pacman_args} ${@}
}

# pacmanの引数を追加する
# https://github.com/FascodeNet/aptpac/blob/master/aptpac のADD_OPTION関数を参考
add_pacman_args() {
    local _pacman_args_array=(${pacman_args})
    _pacman_args_array+=(${@})
    pacman_args=${_pacman_args_array[@]}
    msg_debug "PACMAN ARGS: ${pacman_args}"
}

# バージョンを表示して終了
operation_version() {
    # Pyalpmからlibalpmの値を取得
    # 参考: https://pyalpm.readthedocs.io/en/latest/pyalpm/pyalpm.html
    local _libalpm_version="$(python3 -c 'import pyalpm; print(pyalpm.alpmversion())')"
    local _pacman_version="$(pacman -Q pacman | cut -d ' ' -f 2)"
    echo "wfa v${wfa_version} - pacman v${_pacman_version} - libalpm v${_libalpm_version}"
}

# 引数で指定されたパッケージがAUR以外の場所に存在しない場合にのみ正常終了します(AURのパッケージの場合に正常終了)
check_aur_package() {
    local _package="${1}"
    # 参考: https://qiita.com/Hayao0819/items/a8740a17301fafa2fdab
    if [[ -z "$(pacman -Fq "${_package}" 2>/dev/null | grep -o ".*${_package}$")" ]]; then
        #AUR以外のリポジトリに存在しない
        return 0
    else
        return 1
    fi
}

operation_sync() {
    local _package
    for _package in ${specified_packages[@]}; do
        if ! check_aur_package "${_package}"; then
            # 公式パッケージなのでpacmanでそのままインストール
            run_pacman "${_package}"
        else
            # AUR上のパッケージの場合の処理
            msg_error "Getting the AUR package has not been implemented yet." 1
        fi
    done
}


# Parse options
ARGUMENT="${@}"
_opt_short="QRShVd"
_opt_long="query,remove,sync,help,version,debug"

OPT=$(getopt -o ${_opt_short} -l ${_opt_long} -- ${ARGUMENT})
[[ ${?} != 0 ]] && exit 1

eval set -- "${OPT}"
msg_debug "Argument: ${OPT}"
unset OPT _opt_short _opt_long

while :; do
    case ${1} in
        -Q | --query)
            set_operation "query"
            shift 1
            ;;
        -R | --remove)
            set_operation "remove"
            shift 1
            ;;
        -S | --sync)
            set_operation "sync"
            shift 1
            ;;
        -V | --version)
            set_operation "version"
            shift 1
            ;;
        -d | --debug)
            debug=true
            add_pacman_args "--debug"
            shift 1
            ;;
        -h | --help)
            usage
            shift 1
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            msg_error "Invalid argument '${1}'"
            _usage 1
            ;;
    esac
done

specified_packages=(${@})

case "${operation}" in
    "version")
        operation_version
        ;;
    "sync")
        operation_sync
        ;;
    none)
        exit 0
        ;;
    *)
        msg_error "Undefined operation." 1
        ;;
esac
