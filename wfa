#!/usr/bin/env bash
#
# 1. Author info
#
# Yamada Hayao
# Twitter: @Hayao0819
# Email  : hayao@fascode.net
#
# (c) 2019-2020 Fascode Network.
#
# 2. Overview
# 
# Wfa is a multilingual AUR helper written in bash that is being developed to replace yaourt
#
# 3. License
# 
#        DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE 
#                    Version 2, December 2004 
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net> 
#
# Everyone is permitted to copy and distribute verbatim or modified 
# copies of this license document, and changing it is allowed as long 
# as the name is changed. 
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE 
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#

set -eu


######################################################################################
# ここから翻訳データ
# 翻訳はBashの連想配列を使用して行います
# 連想配列名は echo "${LANG}" | cut -d "." -f 1 の実行結果の値です
# 

# 日本語
declare -A ja_JP=(
    ["Undefined operation"]="未定義のオペレーションです"
    ["only one operation may be used at a time"]="一度に使用できるオペレーションは1つだけです"
    ["Failed to set the argument of %s"]="%sの引数の設定に失敗しました"
    ["Setting that command is not currently supported"]="そのコマンドの設定は現在サポートされていません"
    ["Searching in AUR ..."]="AUR内を検索しています..."
    ["No package with an exact name match was found"]="完全に一致する名前のパッケージが見つかりませんでした"
    ["Select a package %s with an exact name match"]="名前が完全に一致するパッケージ %s を選択します"
    ["Download PKGBUILD of %s"]="%s のPKGBUILDをダウンロード"
    ["Get PKGBUILD from %s"]="%sからPKGBUILDを取得します"
    ["PKGBUILD has already been downloaded"]="PKGBUILDは既にダウンロードされています"
    ["Do you want to overwrite and download? [n] :"]="上書きダウンロードしますか？ [n] :"
    ["Unpacking the tarball of PKGBUILD ..."]="PKGBUILDを展開しています ..."
    [".SRCINFO was not found.\nGenerating it using makepkg"]=".SCRINFOが見つかりませんでした。makepkgを使用して生成しています"
    ["Conflict(s) was found"]="衝突が見つかりました"
    ["Install dependent packages..."]="依存パッケージをインストールします..."
    ["Found %s"]="%s を見つけました"
    ["Packages to cleanBuild? [n] :"]="パッケージをクリーンビルドしますか？ [n] :"
    ["Could not find all required packages: %s"]="必要なすべてのパッケージが見つかりませんでした: %s"
    ["This is a feature that has not been implemented yet"]="まだ実装されていない機能です"
    ["Package not found on AUR: %s"]="パッケージがAUR上から見つかりませんでした: "
    ["There is no aurvote"]="aurvote が見つかりませんでした"
    ["Please install with %s"]="%s でインストールしてください"
    ["Voted for %s"]="%s に投票しました"
    ["Unvoted for %s"]="%s の投票を解除しました"
    ["Help for this operation is not implemented"]="このオペレーションのヘルプは実装されていません"
    ["(Orphaned)"]="(メンテナ不在)"
    ["[Installed]"]="[インストール済み]"
    ["Operation: %s"]="オペレーション: %s"
    ["Raw popularity: %s"]="人気度の正確な値: %s"
    ["This program is an alpha version that is not yet stable\nIf you find a bug, please share it on GitHub\nhttps://github.com/hayao0819/wfa/issues"]="このプログラムはまだ安定しないアルファ版です\nもしバグを見つけたらGitHub上で共有してください\nhttps://github.com/hayao0819/wfa/issues"
    ["Please make a contract with me and become a Puella Magi !"]="僕と契約して魔法少女になってよ！ "
    ["%s ARGS: %s"]="%s の引数: %s"
    ["%s %s (+%s) → (+%s)"]="%s %s (+%s) → (+%s)"
    ["Getting post-voting information ..."]="投票後の情報を取得しています..."
    ["no operation specified (use -h for help)"]="オペレーションが指定されていません (-h を使ってヘルプを見て下さい)"
    ["%s: local (%s) is newer than AUR (%s)"]="%s: ローカルのパッケージ (%s) は AUR (%s) よりも新しいバージョンです"
    ["Searching AUR for updates..."]="AUR からアップデートを検索..."
    ["Getting information from AUR..."]="AUR から情報を取得..."
)


# English
# 翻訳データが存在しない場合はデフォルトメッセージ（英語）が出力されます
# そのため英語の翻訳データは必要ありません
declare -A en_US=()
declare -A C=()

######################################################################################
# ここからデフォルト設定の定義

#-- wfa configs --#
wfa_version="0.1"
wfa_name="WFA"
wfa_command="wfa"
wfa_path="$(dirname "$(realpath "${0}")")/$(basename "${0}")"

#-- options (int) --#
option_y_count=0
sync_clean_count=0

#-- options (str) --#
arch=
aururl="https://aur.archlinux.org/"
operation="none"

#-- options (bool) --#
bash_debug=false
debug=false
force_aur=false
msgdebug=false
nocolor=false
noconfirm=false
nodeps=false
nomakepkgconf=false
sync_search=false
sync_upgrade=false
quiet=false
pass_to_pacman=false
needed=false
changelog=true

#-- ask options (bool) --#
cleanbuild=none
redownload=none

#-- makepkg --#
# 実行ファイル
makepkg_command="/usr/bin/makepkg" 
# 設定ファイル
makepkg_config="/etc/makepkg.conf"
# 引数
makepkg_args=()

#-- pacman --#
# 実行ファイル
pacman_command="/usr/bin/pacman"
# 設定ファイル
pacman_config="/etc/pacman.conf"
# 引数
pacman_args=()

#-- git --#
# 実行ファイル
git_command="/usr/bin/git"
# 引数
git_args=()

#-- gpg --#
# 実行ファイル
gpg_command="/usr/bin/gpg"
# 引数
gpg_args=()

#-- sudo --#
# 実行ファイル
sudo_command="/usr/bin/sudo"
# 引数
sudo_args=()

#-- curl --#
# 実行ファイル
curl_command="/usr/bin/curl"
# 引数
curl_args=()


######################################################################################
# ここからメッセージ関連の関数定義
# テキストの翻訳
translate() {
    local _get_text _locale _translated_text
    _locale="$(echo "${LANG}" | cut -d "." -f 1)"
    _get_text() {
        [[ -z "${*+SET}" ]] && return 1
        #_translated_text="$(set +eu ; eval echo '$'{${_locale}[\"${*}\"]} ; set -eu)"
        set +u
        _translated_text="$(eval "echo \${${_locale}[\"${*}\"]}")"
        set -u
        if [[ -z "${_translated_text}" ]]; then
            if [[ ! "${_locale}" = "C" ]] && [[ ! "${_locale}" = "en_US" ]] && [[ "${debug}" = true ]]; then
                echo "$(text -nc cyan "[WFA]") $(text -nc yellow "Warning") No translation data was found (${*})" 1>&2
            fi
            echo "${*}"
        else
            echo "${_translated_text}"
        fi
    }
    local _text _fulltext=() _main
    if declare -p "${_locale}" 2> /dev/null 1>/dev/null; then
        _main="$(_get_text "${1}")"
    else
        _main="${1}"
    fi
    shift 1

    #shellcheck disable=SC2059
    printf "${_main}\n" "${@}"
    #echo "${_main}"
}

# msg_common [-n] <label color> <label> <str1> <str2> ...
msg_common(){
    [[ "${msgdebug}" = true  ]] && set -xv
    [[ "${msgdebug}" = false ]] && set +xv
    local _msg_opts=("-e") _count _message _label
    _label="$(text -nc "${1}" "${2}")" && shift 2
    [[ "${1}" = "-n" ]] && _msg_opts+=("-n") && shift 1
    _message="$(text "${@}")"
    for _count in $(seq "1" "$(echo -ne "${_message}\n" | wc -l)"); do
        echo "${_msg_opts[@]}" "$(text -nc cyan "[WFA]") ${_label} $(echo -e "${_message}" | head -n "${_count}" | tail -n 1 )"
    done
    [[ "${bash_debug}" = true  ]] && set -xv
    [[ "${bash_debug}" = false ]] && set +xv
    return 0
}

# Show an INFO message
# $1: message string
msg_info() { msg_common green "   Info" "${@}"; }

# Show an Warning message
# $1: message string
msg_warn() { msg_common yellow "Warning" "${@}"; }

# Show an debug message
# $1: message string
msg_debug() { [[ "${debug}" = true ]] && msg_common magenta "  Debug" "${@}"; return 0;}

# Show an ERROR message then exit with status
# $1: message string
msg_error() { msg_common red "  Error" "${@}"; }

# 使い方
# text [-b/-c color/-n/-f/-l/]
text() {
    local OPTIND OPTARG arg _textcolor _decotypes="" _message _notranslate=false
    while getopts "c:bnfl" arg; do
        case "${arg}" in
            c)
                case "${OPTARG}" in
                    "black"   ) _textcolor="30" ;;
                    "red"     ) _textcolor="31" ;;
                    "green"   ) _textcolor="32" ;;
                    "yellow"  ) _textcolor="33" ;;
                    "blue"    ) _textcolor="34" ;;
                    "magenta" ) _textcolor="35" ;;
                    "cyan"    ) _textcolor="36" ;;
                    "white"   ) _textcolor="37" ;;
                    *         ) return 1        ;;
                esac
                ;;
            b) _decotypes="${_decotypes};1" ;;
            f) _decotypes="${_decotypes};5" ;;
            l) _decotypes="${_decotypes};4" ;;
            n) _notranslate=true            ;;
            *) : ;;
        esac
    done
    shift "$((OPTIND - 1))"
    [[ "${_notranslate}" = false ]] && _message="$(translate "${@}")" || _message="${*}"
    if [[ "${nocolor}" = true ]]; then
        echo -ne "${@}"
    else
        echo -ne "\e[$([[ -v _textcolor ]] && echo -n ";${_textcolor}"; [[ -v _decotypes ]] && echo -n "${_decotypes}")m${_message}\e[m"
    fi
}

######################################################################################
# ここから実際の処理開始
# ここから下のメッセージは翻訳可能です

# Show message when file is removed
# remove <file> <file> ...
remove() {
    local _file
    for _file in "${@}"; do msg_debug "Removing ${_file}"; rm -rf "${_file}"; done
}

usage (){
    local _pacman_help="${pass_to_pacman}"

    local _wfa_usage
    _wfa_usage() {
        echo "Usage:"
        echo "${wfa_command}"
        echo "${wfa_command} <operation> [...]"
        echo
        echo "operations:"
        echo "    ${wfa_command} {-h --help}"
        echo "    ${wfa_command} {-A --vote}"
        echo "    ${wfa_command} {-V --version}"
        echo "    ${wfa_command} {-D --database}    <options> <package(s)>"
        echo "    ${wfa_command} {-F --files}       [options] [package(s)]"
        echo "    ${wfa_command} {-Q --query}       [options] [package(s)]"
        echo "    ${wfa_command} {-R --remove}      [options] <package(s)>"
        echo "    ${wfa_command} {-S --sync}        [options] [package(s)]"
        echo "    ${wfa_command} {-T --deptest}     [options] [package(s)]"
        echo "    ${wfa_command} {-U --upgrade}     [options] <file(s)>"
        #echo
        #echo "New operations:"
        #echo "    ${wfa_command} {-P --show}        [options]"
        #echo "    ${wfa_command} {-G --getpkgbuild} [package(s)]"
        echo
        echo "New options:"
        echo "       --repo             Assume targets are from the repositories"
        echo "    -a --aur              Assume targets are from the AUR"
        echo
        echo "Permanent configuration options:"
        echo "    --aururl      <url>   Set an alternative AUR URL"
        echo "    --makepkg     <file>  makepkg command to use"
        echo "    --mflags      <flags> Pass arguments to makepkg"
        echo "    --pacman      <file>  pacman command to use"
        echo "    --git         <file>  git command to use"
        echo "    --gitflags    <flags> Pass arguments to git"
        echo "    --gpg         <file>  gpg command to use"
        echo "    --gpgflags    <flags> Pass arguments to gpg"
        echo "    --config      <file>  pacman.conf file to use"
        echo "    --makepkgconf <file>  makepkg.conf file to use"
        echo "    --nomakepkgconf       Use the default makepkg.conf"
        echo
        echo "wfa specific options:"
        echo "    -c --clean            Remove unneeded dependencies"
        echo
        echo "This program is an alpha version that is not yet stable"
        echo "If you find a bug, please share it on GitHub"
        echo "https://github.com/hayao0819/wfa/issues"
        echo
    }

    local _wfa_usage_sync
    _wfa_usage_sync() {
        echo "usage:  ${wfa_command} {-S --sync} [options] [package(s)]"
        echo "options:"
        echo "  -b, --dbpath <path>  set an alternate database location"
        echo "  -c, --clean          remove old packages from cache directory (-cc for all)"
        echo "  -d, --nodeps         skip dependency version checks (-dd to skip all checks)"
        echo "  -s, --search <regex> search remote repositories for matching strings"
        echo "  -u, --sysupgrade     upgrade installed packages (-uu enables downgrades)"
        echo "  -y, --refresh        download fresh package databases from the server"
        echo "                       (-yy to force a refresh even if up to date)"
        echo "      --arch <arch>    set an alternate architecture"
        echo "      --color <when>   colorize the output"
        echo "      --config <path>  set an alternate configuration file"
        echo "      --confirm        always ask for confirmation"
        echo "      --debug          display debug messages"
        echo "      --disable-download-timeout"
        echo "                       use relaxed timeouts for download"
        echo "      --gpgdir <path>  set an alternate home directory for GnuPG"
        echo "      --hookdir <dir>  set an alternate hook location"
        echo "      --ignore <pkg>   ignore a package upgrade (can be used more than once)"
        echo "      --ignoregroup <grp>"
        echo "                       ignore a group upgrade (can be used more than once)"
        echo "      --noconfirm      do not ask for any confirmation"
    }

    local _wfa_usage_remove
    _wfa_usage_remove() {
        echo "usage:  ${wfa_command} {-R --remove} [options] <package(s)>"
        echo "options:"
        echo "  -b, --dbpath <path>  set an alternate database location"
        echo "  -d, --nodeps         skip dependency version checks (-dd to skip all checks)"
        echo "  -u, --unneeded       remove unneeded packages"
        echo "      --arch <arch>    set an alternate architecture"
        echo "      --color <when>   colorize the output"
        echo "      --config <path>  set an alternate configuration file"
        echo "      --confirm        always ask for confirmation"
        echo "      --debug          display debug messages"
        echo "      --disable-download-timeout"
        echo "                       use relaxed timeouts for download"
        echo "      --noconfirm      do not ask for any confirmation"
    }


    local _wfa_usage_version
    _wfa_usage_version(){ _wfa_usage; }

    if [[ "${operation}" = "none" ]]; then
        _wfa_usage
    elif [[ "${_pacman_help}" = true ]]; then
        "${pacman_command}" -h "--${operation}"
    elif [[ "$(type -t "_wfa_usage_${operation}" )" = "function" ]]; then
        eval "_wfa_usage_${operation}"
    else
        case "${operation}" in
            database | deptest | upgrade | files)
                "${pacman_command}" -h "--${operation}"
                ;;
            *)
                msg_error "Help for this operation is not implemented"
                exit 1
                ;;
        esac
    fi
}

set_operation() {
    if [[ "${operation}" = "none" ]]; then
        operation="${1}"
        #add_args pacman "--${operation}"
    elif [[ "${operation}" = "${1}" ]]; then
        return 0
    else
        msg_error "only one operation may be used at a time"
        exit 1
    fi
}

_pacman_conf(){ pacman-conf --config="${pacman_config}" "${@}"; }

run_sudo() { (( UID == 0 )) || eval "sudo" "${@}"; return 0 && eval "${@}"; }

run_pacman() { run_sudo "${pacman_command}" --config "${pacman_config}"  "${@}"; }

wfa() { "${wfa_path}" "${@}"; }

# pacmanの引数を追加する
# https://github.com/FascodeNet/aptpac/blob/master/aptpac のADD_OPTION関数を参考
# Usage: add_args [pacman/makepkg/git/gpg/sudo/curl] <args1> <args2>...
add_args() {
    local _target="${1}" _args_array
    shift 1

    case "${_target}" in
        "makepkg") makepkg_args+=("${@}") ;;
        "pacman" ) pacman_args+=("${@}")  ;;
        "git"    ) git_args=("${@}")      ;;
        "gpg"    ) gpg_args=("${@}")      ;;
        "sudo"   ) sudo_args=("${@}")     ;;
        "curl"   ) curl_args=("${@}")     ;;
        *        )
            msg_error "Failed to set the argument of %s" "${_target}"
            msg_error "Setting that command is not currently supported"
            exit 1
            ;;
    esac

    msg_debug "%s ARGS: %s" "${_target}" "${*}"
}

# 引数で指定されたパッケージがAUR以外の場所に存在しない場合にのみ正常終了します(AURのパッケージの場合に正常終了)
check_repo_package() {
    # 参考: https://qiita.com/Hayao0819/items/a8740a17301fafa2fdab
    pacman -Ssq "${1}" 2>/dev/null | grep -o ".*${1}$" 1> /dev/null 2>&1 && return 0 || return 1;
}


# 引数で指定されたパッケージが既にインストールされている場合は正常終了します。
check_installed_package() { "${pacman_command}" -Qq "${1}" > /dev/null 2>&1 && return 0 || return 1; }

# この関数に渡されたオペレーションが実行中の場合のみ正常終了します。
check_operation() {
    [[ "${operation}" = "none" ]] && msg_error "no operation specified (use -h for help)" && return 2
    [[ ! "${1}" = "${operation}" ]] && { unavailable_in_this_operation ; return 1; }
    return 0
}

# ~/.cacheに相当するディレクトリを返します
get_cache_dir() {
    local _user_config_dir _cache_dir
    if [[ -v XDG_CONFIG_HOME ]]; then
        _user_config_dir="${XDG_CONFIG_HOME}"
    else
        _use_config_dir="${HOME}/.config"
    fi
    if [[ -f "${_use_config_dir}/user-dirs.dirs" ]]; then
        source "${_use_config_dir}/user-dirs.dirs"
    fi
    if [[ -v XDG_CACHE_HOME ]]; then
        _cache_dir="${XDG_CACHE_HOME}"
    else
        _cache_dir="${HOME}/.cache"
    fi
    echo -n "${_cache_dir}"
}

# Usage: get_srcinfo_data <path> <var>
# 参考: https://qiita.com/withelmo/items/b0e1ffba639dd3ae18c0
get_srcinfo_data() {
    local _srcinfo="${1}" _ver="${2}" _srcinfo_json
    _srcinfo_json=$(python << EOF
from srcinfo.parse import parse_srcinfo; import json
text = """
$(cat "${1}")
"""
parsed, errors = parse_srcinfo(text)
print(json.dumps(parsed))
EOF
)
    echo "${_srcinfo_json}" | jq -rc "${2}"
}

get_aur_json() {
    local _aur_json _resultcount
    local _package="${1}"
    _aur_json=$("${curl_command}" "${curl_args[@]}" -sL "https://aur.archlinux.org/rpc/?v=5&type=search&by=name&arg=${_package}" | jq -r)
    _resultcount="$(echo "${_aur_json}" | jq -r ".resultcount")"
    if (( "${_resultcount:-"0"}" != 0 )); then
        echo "${_aur_json}" | jq -r ".results[]"
    fi
}


# AURからパッケージをビルドしてインストールします
# 現在1つのパッケージしか指定できません
install_aur_package() {
    local _package="${1}" _found_packages _aur_json _aur_snapshot_url _aur_version _aur_packagebase

    # Create cache dir
    if [[ ! -v wfa_cache_dir ]]; then
        wfa_cache_dir="$(get_cache_dir)/wfa"
    fi
    mkdir -p "${wfa_cache_dir}/archive"
    mkdir -p "${wfa_cache_dir}/build/${_package}"

    # AurJsonから値を取得
    msg_info "Searching in AUR ..."
    _aur_json="$(get_aur_json "${_package}")"
    if [[ -z "${_aur_json}" ]]; then
        msg_error "Could not find all required packages: %s" "${_package}"
        exit 1
    fi
    _found_packages="$(echo "${_aur_json}" | jq -r --tab '.Name')"
    #msg_debug "Found package: $(echo ${_found_packages} | tr '\n' ' ')"

    if grep -qx "${_package}" <<< "${_found_packages}" ; then
        msg_debug "Select a package %s with an exact name match" "${_package}"
    else
        msg_error "No package with an exact name match was found"
        exit 1
    fi

    # JSONからから取得した値を変数に代入
    _aur_json=$(echo "${_aur_json}" | jq -r "select(.Name == \"${_package}\")" )
    _aur_snapshot_url="${aururl%/}$(echo "${_aur_json}" | jq -r ".URLPath")"
    _aur_version="$(echo "${_aur_json}" | jq -r ".Version")"
    _aur_packagebase="$(echo "${_aur_json}" | jq -r ".PackageBase")"

    # --neededの処理
    if [[ "${needed}" = true ]]; then
        if run_pacman -Qq "${_package}" 2> /dev/null 1>&2 && \
            [[ "$(run_pacman -Q "${_package}" | cut -d " " -f 2 )" = "${_aur_version}" ]] ;then
            msg_info "%s is up to date -- skipping" "$(run_pacman -Q "${_package}" | tr " " "-")"
            return 0
        fi
    fi

    # PKGBUILDをダウンロード
    msg_info "Download PKGBUILD of %s" "${_package}"
    msg_debug "Get PKGBUILD from %s" "${_aur_snapshot_url}"

    local _pkgbuild_archive_path="${wfa_cache_dir}/archive/${_package}-${_aur_version}"
    local _download_pkgbuild=true
    if [[ -f "${_pkgbuild_archive_path}" ]]; then
        msg_warn "PKGBUILD has already been downloaded"
        msg_warn -n "Do you want to overwrite and download? [n] :"
        local _yes_or_no
        if [[ "${redownload}" = "true" ]] || [[ "${redownload}" = "false" ]]; then
            _download_pkgbuild="${redownload}"
        elif [[ "${noconfirm}" = true ]]; then
            echo
            _yes_or_no="No"
        else
            read -r _yes_or_no
        fi
        case "${_yes_or_no}" in
            "y" | "Y" | "yes" | "Yes" | "YES" ) redownload=true  ;;
            *                                 ) redownload=false ;;
        esac
    fi
    if [[ "${_download_pkgbuild}" = true ]]; then
        remove "${_pkgbuild_archive_path}"
        "${curl_command}" "${curl_args[@]}" -L -C - -f -o "${_pkgbuild_archive_path}" "${_aur_snapshot_url}"
    fi

    # PKGBUILDを展開
    msg_info "Unpacking the tarball of PKGBUILD ..."
    tar -xv -f "${_pkgbuild_archive_path}" -C "${wfa_cache_dir}/build/" > /dev/null 2>&1

    # .SRCINFOを解析
    local _build_dir="${wfa_cache_dir}/build/${_aur_packagebase}"
    if [[ ! -f "${_build_dir}/.SRCINFO" ]]; then
        msg_warn ".SRCINFO was not found.\nGenerating it using makepkg"
        (
            cd "${_build_dir}"
            "${makepkg_command}" --printsrcinfo > "${_build_dir}/.SRCINFO"
        )
    fi

    local _makedepends _depends _conflicts
    #_makedepends="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".makedepends[]?")"
    #_depends="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".depends[]?")"
    readarray -t _depends < <(get_srcinfo_data "${_build_dir}/.SRCINFO" ".depends[]?")
    readarray -t _makedepends < <(get_srcinfo_data "${_build_dir}/.SRCINFO" ".makedepends[]?")
    _conflicts="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".conflicts[]?")"
    msg_debug "makedepends: %s" "${_makedepends[*]}"
    msg_debug "depends: %s" "${_depends[*]}"
    msg_debug "conflicts: %s " "${_conflicts}"


    # 衝突を確認
    local _pkg _conflicts_found=false
    for _pkg in "${_conflicts[@]}" ${_package}; do
        if "${pacman_command}" -Qq "${_pkg}" > /dev/null 2>&1 && [[ ! "$("${pacman_command}" -Qq "${_pkg}" 2> /dev/null)" = "${_package}" ]]; then
            _conflicts_found=true
            msg_error "${_package} is colliding with $("${pacman_command}" -Qq "${_pkg}" 2> /dev/null)"
        fi
    done
    if [[ "${_conflicts_found}" = true ]]; then
        msg_error "Conflict(s) was found"
        exit 1
    fi


    # 依存パッケージをインストール
    if [[ "${nodeps}" = false ]]; then
        msg_info "Install dependent packages..."
        local _force_aur="${force_aur}"
        force_aur=false

        local __package
        local __install_list=()
        local __remove_list=()

        # dependsからインストールされていないパッケージをインストール
        for __package in "${_depends[@]}"; do
            if ! check_installed_package "${__package}"; then
                __install_list+=("${__package}")
            fi
        done

        # makedependsからインストールされていないパッケージをインストール
        for __package in "${_makedepends[@]}"; do
            if ! check_installed_package "${__package}"; then
                __install_list+=("${__package}")

                # もしdependsに含まれていないなら
                if [[ $(printf '%s\n' "${_depends[@]}" | grep -qx "${__package}"; echo -n ${?} ) -eq 0 ]]; then
                    __remove_list+=("${__package}")
                fi
            fi
        done


        install_package "${__install_list[@]}"
        force_aur="${_force_aur}"
        unset _force_aur
    fi

    # ビルド準備
    # srcdirの確認
    if [[ -d "${_build_dir}/src" ]]; then
        msg_info "Found %s" "${_build_dir}/src"
        msg_info -n "Packages to cleanBuild? [n] :"
        local _yes_or_no
        unset _yes_or_no
        if [[ "${cleanbuild}" = "true" ]] || [[ "${cleanbuild}" = "false" ]]; then
            :
        elif [[ "${noconfirm}" = true ]]; then
            echo
            _yes_or_no="No"
        else
            read -r _yes_or_no
        fi
        case "${_yes_or_no}" in
            "y" | "Y" | "yes" | "Yes" | "YES" )  cleanbuild=true;;
        esac
        [[ "${cleanbuild}" = true ]] && add_args makepkg "--clean"
    fi


    # ビルド
    add_args "makepkg" "-sf"
    (
        cd "${_build_dir}"
        "${makepkg_command}" "${makepkg_args[@]}"
    )


    # ビルド後のパッケージ一覧を生成
    (
        cd "${_build_dir}"
        "${makepkg_command}" --printsrcinfo > "${_build_dir}/.SRCINFO"
    )
    local _pkgnames _pkgver _pkgrel _arch_array _PKGEXT
    _pkgver="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".pkgver" | sed 's/ //g')"
    _pkgrel="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".pkgrel" | sed 's/ //g')"

    #_pkgnames=($(get_srcinfo_data "${_build_dir}/.SRCINFO" ".packages | keys[]"))
    readarray -t _pkgnames < <(get_srcinfo_data "${_build_dir}/.SRCINFO" ".packages | keys[]")
    #_arch_array=($(get_srcinfo_data "${_build_dir}/.SRCINFO" ".arch[]"))
    readarray -t _arch_array < <(get_srcinfo_data "${_build_dir}/.SRCINFO" ".arch[]")

    local _arch _pkgname
    if [[ "${_arch_array[*]}" = "any" ]]; then
        _arch="any"
    else
        _arch="${arch}"
    fi
    _PKGEXT=$(
        source "${makepkg_config}"
        echo "${PKGEXT}"
    )
    
    #for _pkgname in ${_pkgnames[@]}; do
    #    _pkgfilelist+=("${_build_dir}/${_pkgname}-${_pkgver}-${_pkgrel}-${_arch}${_PKGEXT}")
    #done

    readarray -t _pkgfilelist < <(
        cd "${_build_dir}"
        "${makepkg_command}" --packagelist
    )
    _pkgfilelist+=("${_build_dir}/${_package}-${_pkgver}-${_pkgrel}-${_arch}${_PKGEXT}")

    # インストール
    local _installed=()
    for _pkgfile in "${_pkgfilelist[@]}"; do
        printf "%s\n" "${_installed[@]}" | grep -qx "${_pkgfile}" && continue
        [[ ! -f "${_pkgfile}" ]] && continue
        run_pacman "${pacman_args[@]}" -U --noconfirm "${_pkgfile}" && _installed+=("${_pkgfile}")
    done


    # ビルド後に不要なパッケージを削除
    if (( "${#__remove_list[@]}" != 0 )); then
        run_pacman -R --noconfirm "${__remove_list[*]}"
    fi
}

# AURのパッケージを検索
search_aur_package() {
    local _package="${1}" _aur_json
    _aur_json="$(get_aur_json "${_package}")"
    if [[ -z "${_aur_json}" ]]; then
        msg_error "Could not find all required packages: %s" "${_package}"
        exit 1
    fi
    #local _found_pkgname=($(echo "${_aur_json}" | jq -r ".Name" ))
    readarray -t _found_pkgname < <(jq -r ".Name" <<< "${_aur_json}")

    if [[ "${quiet}" = true ]]; then
        local _IFS="${IFS}"
        IFS=$'\n'
        echo "${_found_pkgname[*]}"
        IFS="${_IFS}"
    else
        local  _found_package __pkgver __popularity __vote __pkgdesc __orphaned __installed __output_text=()
        for _found_package in "${_found_pkgname[@]}"; do
            __orphaned=false
            __installed=false
            _found_json="$(echo "${_aur_json}" | jq "select(.Name == \"${_found_package}\")")"

            #echo "${_found_json}"
            __pkgver="$(echo "${_found_json}" | jq -r ".Version" )"
            __popularity="$(echo "${_found_json}" | jq -r ".Popularity" )"
            __vote="$(echo "${_found_json}" | jq -r ".NumVotes" )"
            __pkgdesc="$(echo "${_found_json}" | jq -r ".Description" )"

            # 人気度の少数2位以下を四捨五入
            # 参考: http://www.rivhiro-weather.com/knowledge/?p=536
            msg_debug "Raw popularity: %s" "${__popularity}"
            __popularity="$(printf "%g\n" "${__popularity}" | awk '{printf("%4.2f", $1)}')"

            # 孤児判定
            #参考: https://www.366service.com/jp/qa/7c95f46e5236039134ff5b862ae2cd13
            if ! echo "${_found_json}" | jq -r --exit-status ".Maintainer" 1> /dev/null 2> /dev/null ; then
                __orphaned=true
            fi

            # インストール済み判定
            if check_installed_package "${_found_package}"; then
                __installed=true
            fi

            __output_text+=(
                "$(text -n -c blue -b "aur")/$(text -n -b "${_found_package}") $(text -n -c cyan "${__pkgver}") (+$(text -n -b "${__vote} ${__popularity}"))"
            )
            
            if [[ "${__orphaned}" = true ]]; then
                __output_text+=("$(text -bc red "(Orphaned)")")
            fi

            if [[ "${__installed}" = true ]]; then
                __output_text+=("$(text -bc cyan "[Installed]")")
            fi
            echo "${__output_text[*]}"
            echo "    ${__pkgdesc}"
            unset __pkgver __popularity __vote __pkgdesc _found_json __orphaned __installed __output_text
        done
    fi
}

# バージョンを表示して終了
operation_version() {
    local _libalpm_version _pacman_version

    # Pyalpmからlibalpmの値を取得
    # 参考: https://pyalpm.readthedocs.io/en/latest/pyalpm/pyalpm.html
    _libalpm_version="$(python3 -c 'import pyalpm; print(pyalpm.alpmversion())')"
    _pacman_version="$("${pacman_command}" -Q pacman | cut -d ' ' -f 2)"
    echo "wfa v${wfa_version} - pacman v${_pacman_version} - libalpm v${_libalpm_version}"
}

operation_remove() {
    local _package _not_found=false
    for _package in "${specified_packages[@]}"; do
        if ! check_installed_package "${_package}"; then
            msg_error "target not found: %s" "${_package}"
            _not_found=true
        fi
    done
    if [[ "${_not_found}" = true ]]; then
        exit 1
    else
        run_pacman -R "${pacman_args[@]}" "${specified_packages[@]}"
    fi
}

# Usage: install_package <package1> <package2>...
install_package() {
    local _package _repo_packages=() _aur_packages=()
    for _package in "${@}"; do
        [[ -z "${_package:-""}" ]] && msg_error "Null characoer was passwd to install_package." && exit 1
        if ! check_installed_package "${_package}"; then
            if check_repo_package "${_package}"; then
                # 公式パッケージなのでpacmanでそのままインストール
                _repo_packages+=("${_package}")
            else
                # AUR上のパッケージの場合の処理
                _aur_packages+=("${_package}")
            fi
        fi
    done

    if (( "${#_repo_packages[@]}" > 0 )); then
        run_pacman --asdeps -S "${pacman_args[@]}" "${_repo_packages[@]}"
    fi

    if (( "${#_aur_packages[@]}" > 0 )); then
        unset _package
        for _package in "${_aur_packages[@]}"; do
            install_aur_package "${_package}"
        done
    fi
}

upgrade_aur_package() {
    msg_error "This is a feature that has not been implemented yet"
    [[ "${debug}" = false ]] && return 0

    # インストールされているAUR由来のパッケージを検索
    msg_info "Searching AUR for updates..."
    local _aur_json _resultcount _apiurl="${aururl}/rpc/?v=5&type=info"
    while read -r _pkg;do
        _apiurl="${_apiurl}&arg[]=${_pkg}"
    done < <(run_pacman "${pacman_args[@]}" -Qmq)

    _aur_json=$("${curl_command}" "${curl_args[@]}" -sL "${_apiurl}" | jq -r)
    _resultcount="$(echo "${_aur_json}" | jq -r ".resultcount")"
    if (( "${_resultcount:-"0"}" != 0 )); then
        _aur_json="$(echo  "${_aur_json}" | jq -r ".results[]")"
    else
        return 0
    fi

    # 情報を取得
    msg_info "Getting information from AUR..."
    local _aurpkgname _aurpkgremotever _aurpkglocalver
    readarray -t _aurpkgname      < <(jq -r .Name <<< "${_aur_json}")
    readarray -t _aurpkgremotever < <(jq -r .Version <<< "${_aur_json}")
    readarray -t _aurpkglocalver  < <(
        printf "%s\0" "${_aurpkgname[@]}" | xargs -0 -I{} pacman -Q {} | cut -d " " -f 2
    )

    # 値を比較
    local _upgradepkg
    for (( _count=0; _count<= "${#_aurpkgname[@]}" - 1 ; _count++ )); do
        #echo "${_aurpkgname[${_count}]}: remote=${_aurpkgremotever[${_count}]} local=${_aurpkglocalver[${_count}]}"

        # vercmp <Remote> <Local>
        # < 0 => Local is newer than AUR
        # = 0 => Local is the latest version
        # > 0 => Local is out of date 
        _versionStatus="$(vercmp "${_aurpkgremotever[${_count}]}" "${_aurpkglocalver[${_count}]}")"

        (( _versionStatus == 0 )) && continue
        (( _versionStatus < 0 )) && {
            #msg_warn "%s: local (%s) is newer than AUR (%s)" "${_aurpkgname[${_count}]}" "${_aurpkglocalver[${_count}]}" "${_aurpkgremotever[${_count}]}"
            continue
        }
        (( _versionStatus > 0 )) && _upgradepkg+=("${_aurpkgname[${_count}]}")
    done
    printf "%s\n" "${_upgradepkg[@]}"

    exit 0
}

operation_sync(){
    local _package
    if (( "${sync_clean_count}" >= 1 )); then
        remove "$(get_cache_dir)/wfa"
        run_pacman -S "${pacman_args[@]}" "-$(yes "c" | head -n "${sync_clean_count}")"
    fi


    if [[ "${sync_search}" = true ]]; then
        for _package in "${specified_packages[@]}"; do
            search_aur_package "${_package}"
        done
        "${pacman_command}" "${pacman_args[@]}" "${specified_packages[@]}" || true
    else
        if [[ "${sync_upgrade}" = true ]]; then
            upgrade_aur_package
            run_pacman -S "${pacman_args[@]}" --sysupgrade
        fi
        for _package in "${specified_packages[@]}"; do
            if check_repo_package "${_package}" && [[ "${force_aur}" = false ]]; then
                # 公式パッケージなのでpacmanでそのままインストール
                run_pacman -S "${pacman_args[@]}" "${_package}"
            else
                # AUR上のパッケージの場合の処理
                install_aur_package "${_package}"
                #msg_error "Getting the AUR package has not been implemented yet."
                #exit 1
            fi
        done
    fi
}


operation_vote() {

    # aurvoteの確認
    if ! type aurvote 1> /dev/null 2> /dev/null; then
        msg_error "There is no aurvote"
        msg_error "Please install with %s" "\"wfa -S aurvote\""
        exit 1
    fi

    local _package _aur_json _found_result_count _pkgver _before_popularity _before_vote
    for _package in "${specified_packages[@]}"; do

        # 存在するパッケージか確認
        _aur_json="$(get_aur_json "${_package}")"
        if [[ -z "${_aur_json}" ]]; then
            msg_error "Could not find all required packages: %s" "${_package}"
            exit 1
        fi
        _aur_json=$(echo "${_aur_json}" | jq -r "select(.Name == \"${_package}\")")

        # jsonから値を取り出して整形
        msg_info "Searching in AUR ..."
        _pkgver="$(echo "${_aur_json}" | jq -r ".Version" )"
        _before_popularity="$(printf "%g\n" "$(echo "${_aur_json}" | jq -r ".Popularity" )" | awk '{printf("%4.2f", $1)}')"
        _before_vote="$(echo "${_aur_json}" | jq -r ".NumVotes" )"

        # 投票を操作
        if [[ "$(aurvote --check "${_package}")" = "not voted" ]]; then
            msg_info "Voted for %s" "${_package}"
            aurvote --vote "${_package}" 1> /dev/null
        else
            msg_info "Unvoted for %s" "${_package}"
            aurvote --unvote "${_package}" 1> /dev/null
        fi

        # 投票後の値を取得
        msg_info "Getting post-voting information ..."
        _aur_json=$(get_aur_json "${_package}" | jq -r "select(.Name == \"${_package}\")")
        _after_popularity="$(printf "%g\n" "$(echo "${_aur_json}" | jq -r ".Popularity" )" | awk '{printf("%4.2f", $1)}')"
        _after_vote="$(echo "${_aur_json}" | jq -r ".NumVotes" )"

        # 結果を出力
        msg_info "%s %s (+%s) → (+%s)" "$(text -nb "${_package}")" "$(text -nc cyan "${_pkgver}")" "$(text -nb "${_before_vote} ${_before_popularity}")" "$(text -nb "${_after_vote} ${_after_popularity}")"
    done
}

unavailable_in_this_operation() {
    msg_error "This option is not available in the current operation"
    return 1
}

# オペレーションを実行します
run_operation() {
    local _operation="${1}"
    msg_debug "Operation: %s" "${_operation}"
    if [[ "${quiet}" = false ]]; then
        msg_warn "This program is an alpha version that is not yet stable\nIf you find a bug, please share it on GitHub\nhttps://github.com/hayao0819/wfa/issues"
    fi

    eval "operation_${_operation}"
}

# Parse operation
RAW_ARGS=("${@}")
OPTS=("h" "V" "D" "F" "Q" "R" "S" "T" "U" "A")
OPTL=("help" "version" "database" "files" "query" "remove" "sync" "deptest" "upgrade")
GETOPT=(-o "$(printf "%s," "${OPTS[@]}")" -l "$(printf "%s," "${OPTL[@]}")" -- "${@}")
eval set -- "$(getopt -q "${GETOPT[@]}")"
while true; do
    case "${1}" in
        -h | --help    ) usage                                            && exit  0 ;;
        -V | --version ) set_operation "version"  && pass_to_pacman=false && shift 1 ;;
        -D | --database) set_operation "database" && pass_to_pacman=true  && shift 1 ;;
        -F | --files   ) set_operation "files"    && pass_to_pacman=true  && shift 1 ;;
        -Q | --query   ) set_operation "query"    && pass_to_pacman=false && shift 1 ;;
        -R | --remove  ) set_operation "remove"   && pass_to_pacman=false && shift 1 ;;
        -S | --sync    ) set_operation "sync"     && pass_to_pacman=false && shift 1 ;;
        -T | --deptest ) set_operation "deptest"  && pass_to_pacman=true  && shift 1 ;;
        -U | --upgrade ) set_operation "upgrade"  && pass_to_pacman=true  && shift 1 ;;
        -A | --vote    ) set_operation "vote"     && pass_to_pacman=false && shift 1 ;;
        --             ) shift 1 && break ;;
        *              ) shift 1      ;
    esac
done
eval set -- "${RAW_ARGS[@]}"

# Parse options
case "${operation}" in
    "query")
        OPTS+=("b:" "c" "d" "e" "g" "i" "k" "l" "m" "n" "o:" "p:" "q" "r:" "s:" "t" "u" "v")
        OPTL+=("changelog" "deps" "explicit" "groups" "info" "check" "list" "foreign"
               "native" "owns" "file" "quiet" "search" "unrequired" "upgrades")
        GETOPT=(-o "$(printf "%s," "${OPTS[@]}")" -l "$(printf "%s," "${OPTL[@]}")" -- "${@}")
        readarray -t PARSED_ARGS < <(getopt -q "${GETOPT[@]}")
        getopt -Q "${GETOPT[@]}"
        eval set -- "${PARSED_ARGS[@]}"
        while true; do
            case "${1}" in
                -b | --dbpath    ) add_args pacman "--dbpath '${2}'"               && shift 2 ;;
                -c | --changelog ) add_args pacman "--changelog" && changelog=true && shift 1 ;;

            esac
        done
        ;;
    "remove")
        OPTS+=("b:" "c" "d" "n" "p" "r:" "s" "u" "v")
        OPTL+=("cascade" "nodeps" "nosave" "print" "recursive" "unneeded"
               "assume-installed:" "dbonly" "noprogressbar" "noscriptlet" "print-format:")
        GETOPT=(-o "$(printf "%s," "${OPTS[@]}")" -l "$(printf "%s," "${OPTL[@]}")" -- "${@}")
        readarray -t PARSED_ARGS < <(getopt -q "${GETOPT[@]}")
        getopt -Q "${GETOPT[@]}"
        eval set -- "${PARSED_ARGS[@]}"
        ;;
    "sync")
        OPTS+=("b:" "c" "d" "g" "i" "l:" "p" "q" "r:" "s" "u" "v" "w" "y")
        OPTL+=("clean" "nodeps" "groups" "info" "list:" "print" "quiet" "search" "sysupgrade" "downloadonly"
               "refresh" "asdeps" "asexplicit" "assume-installed:" "dbonly" "ignore:" "ignoregroup:" "logfile:"
               "needed" "noprogressbar" "noscriptlet" "overwrite:" "print-format:" "sysroot")
        GETOPT=(-o "$(printf "%s," "${OPTS[@]}")" -l "$(printf "%s," "${OPTL[@]}")" -- "${@}")
        readarray -t PARSED_ARGS < <(getopt -q "${GETOPT[@]}")
        getopt -Q "${GETOPT[@]}"
        eval set -- "${PARSED_ARGS[@]}"
        ;;
    "none")
        msg_error "no operation specified (use -h for help)"
        exit 1
        ;;
esac

# Parse common options
if [[ "${operation}" = "query" ]] || [[ "${operation}" = "remove" ]] || [[ "${operation}" = "sync" ]]; then
    eval set -- "${RAW_ARGS[@]}"
    OPTS+=("b:" "r:" "v")
    OPTL+=("dbpath:" "root:" "verbose" "arch:" "cachedir:" "color:" "config:" "confirm" "debug" "disable-download-timeout" "gpgdir:" "hookdir:" "logfile:" "noconfirm" "sysroot")
    GETOPT=(-o "$(printf "%s," "${OPTS[@]}")" -l "$(printf "%s," "${OPTL[@]}")" -- "${@}")
    readarray -t PARSED_ARGS < <(getopt -q "${GETOPT[@]}")
    getopt -Q "${GETOPT[@]}"
    eval set -- "${PARSED_ARGS[@]}"
fi
unset OPTS OPTL

exit 0

OPTS=("d" "b:" "a" "y" "s" "u" "c" "q" "n" "k" "r:")
OPTL=("query" "remove" "sync" "help" "version" "debug" "dbpath:" "aururl" "aur" "noconfirm" "config:" "makepkg:" "mflags:" "pacman:" "git:" "gitflags:" "gpg:" "gpgflags:" "makepkgconf:" "nomakepkgconf" "nodeps" "refresh" "bash-debug" "msg-debug" "sysupgrade" "color:" "nocolor" "clean" "quiet" "arch:" "confirm" "disable-download-timeout" "curl:" "curlflags:" "unneeded" "puella" "wfa-debug" "cascade" "ignoregroup:" "ignore:" "hookdir:" "gpgdir:" "cachedir:" "check" "root:" "asdeps" "asexplicit" "needed")
GETOPT=(-o "$(printf "%s," "${OPTS[@]}")" -l "$(printf "%s," "${OPTL[@]}")" -- "${@}")
readarray -t PARSED_ARGS < <(getopt "${GETOPT[@]}")



unset OPTS OPTL



if [[ "${pass_to_pacman}" = false ]]; then
    eval set -- "${PARSED_ARGS[@]}"
    getopt -Q "${GETOPT[@]}" || exit 1

    while true; do
        case "${1}" in
            #-- Simple short options --#
            -a | --aur    ) force_aur=true                            && shift 1 ;;
            -b | --dbpath ) add_args pacman "--dbpath '${2}'"         && shift 2 ;;
            -k | --check  ) add_args pacman "--check"                 && shift 1 ;;
            -y | --refresh) option_y_count=$(( option_y_count + 1 ))  && shift 1 ;;
            -n | --nosave ) add_args pacman "--nosave"                && shift 1 ;;
            -r | --root   ) add_args pacman "--root" "${2}"           && shift 1 ;;
            -d | --nodeps ) add_args pacman "--nodeps" && nodeps=true && shift 1 ;;
            -q | --quiet  ) add_args pacman "--quiet"  && quiet=true  && shift 1 ;;
            -h | --help   ) usage                                     && exit  0 ;;

            #-- Simple long options --#
            --asdeps      ) add_args pacman "--asdeps"                              && shift 1 ;;
            --asexplicit  ) add_args pacman "--asexplicit"                          && shift 1 ;;
            --arch        ) add_args pacman "--arch ${2}"      && arch="${2}"       && shift 2 ;;
            --aururl      ) aururl="${2}"                                           && shift 2 ;;
            --bash-debug  ) bash_debug=true                    && set -xv           && shift 1 ;;
            --clean       ) sync_clean_count=$(( sync_clean_count + 1 ))            && shift 1 ;;
            --cascade     ) add_args pacman "--cascade"                             && shift 1 ;;
            --cachedir    ) add_args pacman "--cachedir" "${2}"                     && shift 2 ;;
            --curl        ) curl_command="${2}"                                     && shift 2 ;;
            --curlflags   ) add_args curl "${2}"                                    && shift 2 ;;
            --confirm     ) noconfirm=false                                         && shift 1 ;;
            --config      ) pacman_config="${2}" && add_args pacman "--config ${2}" && shift 2 ;;
            --debug       ) debug=true           && add_args pacman "--debug"       && shift 1 ;;
            --gpgdir      ) add_args pacman "--gpgdir ${2}"                         && shift 2 ;;
            --git         ) git_command="${2}"                                      && shift 2 ;;
            --gitflags    ) add_args git "${2}"                                     && shift 2 ;;
            --hookdir     ) add_args pacman "--hookdir ${2}"                        && shift 2 ;;
            --ignoregroup ) add_args pacman "--ignoregroup ${2}"                    && shift 2 ;;
            --ignore      ) add_args pacman "--ignore ${2}"                         && shift 2 ;;
            --makepkg     ) makepkg_command="${2}"                                  && shift 2 ;;
            --mflags      ) add_args makepkg "${2}"                                 && shift 2 ;;
            --msg-debug   ) msgdebug=true                                           && shift 1 ;;
            --noconfirm   ) add_args pacman "--noconfirm"   && noconfirm=true       && shift 1 ;;
            --nocolor     ) add_args pacman "--color never" && nocolor=true         && shift 1 ;;
            --needed      ) add_args pacman "--needed"      && needed=true          && shift 1 ;;
            --pacman      ) pacman_command="${2}"                                   && shift 2 ;;
            --recursive   ) add_args pacman "--recursive"                           && shift 1 ;;
            --search      ) sync_search=true                                        && shift 1 ;;
            --sysupgrade  ) sync_upgrade=true                                       && shift 1 ;;
            --unneeded    ) add_args pacman "--unneeded"                            && shift 1 ;;
            --wfa-debug   ) debug=true                                              && shift 1 ;;

            #-- Other long options --#
            --color)
                case "${2}" in
                    "never")
                        nocolor=true
                        add_args pacman "--color never"
                        ;;
                    "always")
                        nocolor=false
                        add_args pacman "--color always"
                        ;;
                    "auto")
                        msg_error "auto is not currently supported."
                        add_args pacman "--color auto"
                        ;;
                esac
                shift 2
                ;;
            --disable-download-timeout)
                add_args curl "--max-time 0"
                add_args pacman "--disable-download-timeout"
                shift 1
                ;;
            --makepkgconfig)
                if [[ "${nomakepkgconf}" = false ]]; then
                    makepkg_config="${2}"
                else
                    msg_warn "--nomakepkgconf is specified.\n--makepkgconf has been ignored."
                fi
                shift 2
                ;;
            --nomakepkgconf)
                makepkg_config="/etc/makepkg.conf"
                nomakepkgconf=true
                shift 1
                ;;
            --puella)
                text -flb "Please make a contract with me and become a Puella Magi !"
                echo
                shift 1
                exit 0
                ;;

            #-- Other short options --#
            -s)
                case "${operation}" in
                    "sync")
                        add_args pacman "--search"
                        sync_search=true
                        ;;
                    "remove")
                        add_args pacman "--recursive"
                        ;;
                    *)
                        unavailable_in_this_operation
                        ;;
                esac
                shift 1
                ;;
            -u)
                case "${operation}" in
                    "sync") 
                        sync_upgrade=true;;
                    "remove")
                        add_args pacman "--unneeded"
                        ;;
                    "none")
                        :
                        ;;
                    *)
                        unavailable_in_this_operation
                        ;;
                esac
                shift 1
                ;;
            -c)
                case "${operation}" in
                    "sync")
                        sync_clean_count=$(( sync_clean_count + 1 ))
                        ;;
                    "remove")
                        add_args pacman "--cascade"
                        ;;
                    *)
                        unavailable_in_this_operation
                        ;;
                esac
                shift 1
                ;;

            #-- for getopt --#
            --) shift 1 && break ;;
            * ) shift 1          ;;
        esac
    done

    specified_packages=("${@}")
fi

# Get architecture fron pacman.conf
[[ -z "${arch-""}" ]] && arch="$(_pacman_conf Architecture)"

# Show message
[[ "${force_aur}" = true ]] && msg_debug "Assume targets are from the AUR"


if [[ "${pass_to_pacman}" = false ]]; then
    # Run database update
    if (( "${option_y_count}" == 1 )); then
        run_pacman "${pacman_args[@]}" -Sy
    elif (( "${option_y_count}" >= 2 )); then
        run_pacman "${pacman_args[@]}" -Syy
    fi
fi

# set_operationで設定された操作を実行
case "${operation}" in
    "version" | "sync" | "remove" | "vote")
        run_operation "${operation}"
        ;;
    "database" | "deptest" | "upgrade" | "files")
        run_pacman "${RAW_ARGS[@]}"
        ;;
    "none")
        msg_error "no operation specified (use -h for help)"
        exit 1
        ;;
    *)
        msg_error "Undefined operation"
        exit 1
        ;;
esac
