#!/usr/bin/env bash
#
# 1. Author info
#
# Yamada Hayao
# Twitter: @Hayao0819
# Email  : hayao@fascode.net
#
# (c) 2019-2020 Fascode Network.
#
# 2. Overview
# 
# Wfa is a multilingual AUR helper written in bash that is being developed to replace yaourt
#
# 3. License
# 
#        DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE 
#                    Version 2, December 2004 
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net> 
#
# Everyone is permitted to copy and distribute verbatim or modified 
# copies of this license document, and changing it is allowed as long 
# as the name is changed. 
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE 
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#

set -eu


######################################################################################
# ここから翻訳データ
# 翻訳はBashの連想配列を使用して行います
# 連想配列名は echo "${LANG}" | cut -d "." -f 1 の実行結果の値です
# 

# 日本語
declare -A ja_JP=(
    ["Undefined operation"]="未定義のオペレーションです"
    ["only one operation may be used at a time"]="一度に使用できるオペレーションは1つだけです"
    ["Failed to set the argument of %s"]="%sの引数の設定に失敗しました"
    ["Setting that command is not currently supported"]="そのコマンドの設定は現在サポートされていません"
    ["Searching in AUR ..."]="AUR内を検索しています..."
    ["No package with an exact name match was found"]="完全に一致する名前のパッケージが見つかりませんでした"
    ["Select a package %s with an exact name match"]="名前が完全に一致するパッケージ %s を選択します"
    ["Download PKGBUILD of %s"]="%s のPKGBUILDをダウンロード"
    ["Get PKGBUILD from %s"]="%sからPKGBUILDを取得します"
    ["PKGBUILD has already been downloaded"]="PKGBUILDは既にダウンロードされています"
    ["Do you want to overwrite and download? [n] :"]="上書きダウンロードしますか？ [n] :"
    ["Unpacking the tarball of PKGBUILD ..."]="PKGBUILDを展開しています ..."
    [".SRCINFO was not found.\nGenerating it using makepkg"]=".SCRINFOが見つかりませんでした。makepkgを使用して生成しています"
    ["Conflict(s) was found"]="衝突が見つかりました"
    ["Install dependent packages..."]="依存パッケージをインストールします..."
    ["Found %s"]="%s を見つけました"
    ["Packages to cleanBuild? [n] :"]="パッケージをクリーンビルドしますか？ [n] :"
    ["Could not find all required packages: %s"]="必要なすべてのパッケージが見つかりませんでした: %s"
    ["This is a feature that has not been implemented yet"]="まだ実装されていない機能です"
    ["Package not found on AUR: %s"]="パッケージがAUR上から見つかりませんでした: "
    ["There is no aurvote"]="aurvote が見つかりませんでした"
    ["Please install with %s"]="%s でインストールしてください"
    ["Voted for %s"]="%s に投票しました"
    ["Unvoted for %s"]="%s の投票を解除しました"
    ["Help for this operation is not implemented"]="このオペレーションのヘルプは実装されていません"
    ["(Orphaned)"]="(メンテナ不在)"
    ["[Installed]"]="[インストール済み]"
    ["Operation: %s"]="オペレーション: %s"
    ["Raw popularity: %s"]="人気度の正確な値: %s"
    ["This program is an alpha version that is not yet stable\nIf you find a bug, please share it on GitHub\nhttps://github.com/hayao0819/wfa/issues"]="このプログラムはまだ安定しないアルファ版です\nもしバグを見つけたらGitHub上で共有してください\nhttps://github.com/hayao0819/wfa/issues"
    ["Please make a contract with me and become a Puella Magi !"]="僕と契約して魔法少女になってよ！ "
    ["%s ARGS: %s"]="%s の引数: %s"
    ["%s %s (+%s) → (+%s)"]="%s %s (+%s) → (+%s)"
    ["Getting post-voting information ..."]="投票後の情報を取得しています..."
)


# English
# 翻訳データが存在しない場合はデフォルトメッセージ（英語）が出力されます
# そのため英語の翻訳データは必要ありません
declare -A en_US=()
declare -A C=()

######################################################################################
# ここからデフォルト設定の定義

#-- wfa configs --#
wfa_version="0.1"
wfa_name="WFA"
wfa_command="wfa"
wfa_path="$(dirname "$(realpath "${0}")")/$(basename "${0}")"

#-- options (int) --#
option_y_count=0
sync_clean_count=0

#-- options (str) --#
arch="$(uname -m)"
aururl="https://aur.archlinux.org/"
operation="none"

#-- options (bool) --#
bash_debug=false
debug=false
force_aur=false
msgdebug=false
nocolor=false
noconfirm=false
nodeps=false
nomakepkgconf=false
sync_search=false
sync_upgrade=false
quiet=false

#-- makepkg --#
# 実行ファイル
makepkg_command="/usr/bin/makepkg" 
# 設定ファイル
makepkg_config="/etc/makepkg.conf"
# 引数
makepkg_args=""

#-- pacman --#
# 実行ファイル
pacman_command="/usr/bin/pacman"
# 設定ファイル
pacman_config="/etc/pacman.conf"
# 引数
pacman_args=""

#-- git --#
# 実行ファイル
git_command="/usr/bin/git"
# 引数
git_args=""

#-- gpg --#
# 実行ファイル
gpg_command="/usr/bin/gpg"
# 引数
gpg_args=""

#-- sudo --#
# 実行ファイル
sudo_command="/usr/bin/sudo"
# 引数
sudo_args=""

#-- curl --#
# 実行ファイル
curl_command="/usr/bin/curl"
# 引数
curl_args=""


######################################################################################
# ここからメッセージ関連の関数定義
# テキストの翻訳
translate() {
    local _get_text _locale="$(echo "${LANG}" | cut -d "." -f 1)"
    _get_text() {
        [[ -z "${*+SET}" ]] && return 1
        local _translated_text="$(set +eu ; eval echo '$'{${_locale}[\"${*}\"]} ; set -eu)"
        if [[ -z "${_translated_text}" ]]; then
            if [[ ! "${_locale}" = "C" ]] && [[ ! "${_locale}" = "en_US" ]]; then
                echo "$(text -nc cyan "[WFA]") $(text -nc yellow "Warning") No translation data was found (${*})" 1>&2
            fi
            echo "${*}"
        else
            echo "${_translated_text}"
        fi
    }
    local _text _fulltext=() _main
    if declare -p "${_locale}" 2> /dev/null 1>/dev/null; then
        _main="$(_get_text "${1}")"
    else
        _main="${1}"
    fi
    shift 1
    echo "$(printf "${_main}" "${@}")"
}

msg_common(){
    local _msg_opts=() _count
    [[ "${1}" = "-n" ]] && _msg_opts+=("-n") && shift 1
    [[ "${msgdebug}" = true ]] && set -xv || set +xv
    local _label="${1}" && shift 1
    local _message="$(text "${@}")"
    for _count in $(seq "1" "$(echo -ne "${_message}\n" | wc -l)"); do
        echo "$(text -nc cyan "[WFA]") ${_label} $(echo -ne "${_message}\n" | head -n "${_count}" | tail -n 1 )"
    done
    [[ "${bash_debug}" = true ]] && set -xv || set +xv
}

# Show an INFO message
# $1: message string
msg_info() { msg_common "$(text -nc green "   Info")" "${@}"; }

# Show an Warning message
# $1: message string
msg_warn() { msg_common "$(text -nc yellow "Warning")" "${@}"; }

# Show an debug message
# $1: message string
msg_debug() { [[ "${debug}" = true ]] && msg_common "$(text -nc magenta "  Debug")" "${@}"; return 0;}

# Show an ERROR message then exit with status
# $1: message string
msg_error() { msg_common "$(text -nc red "  Error")" "${@}"; }

# 使い方
# text [-b/-c color/-n/-f/-l/]
text() {
    local OPTIND OPTARG arg _textcolor _decotypes="" _message _notranslate=false
    while getopts "c:bnfl" arg; do
        case "${arg}" in
            c)
                case "${OPTARG}" in
                    "black"   ) _textcolor="30" ;;
                    "red"     ) _textcolor="31" ;;
                    "green"   ) _textcolor="32" ;;
                    "yellow"  ) _textcolor="33" ;;
                    "blue"    ) _textcolor="34" ;;
                    "magenta" ) _textcolor="35" ;;
                    "cyan"    ) _textcolor="36" ;;
                    "white"   ) _textcolor="37" ;;
                    *         ) return 1        ;;
                esac
                ;;
            b) _decotypes="${_decotypes};1" ;;
            f) _decotypes="${_decotypes};5" ;;
            l) _decotypes="${_decotypes};4" ;;
            n) _notranslate=true            ;;
        esac
    done
    shift "$((OPTIND - 1))"
    [[ "${_notranslate}" = false ]] && _message="$(translate "${@}")" || _message="${@}"
    if [[ "${nocolor}" = true ]]; then
        echo -ne "${@}"
    else
        echo -ne "\e[$([[ -v _textcolor ]] && echo -n ";${_textcolor}"; [[ -v _decotypes ]] && echo -n "${_decotypes}")m${_message}\e[m"
    fi
}

######################################################################################
# ここから実際の処理開始
# ここから下のメッセージは翻訳可能です

# Show message when file is removed
# remove <file> <file> ...
remove() {
    local _file
    for _file in "${@}"; do msg_debug "Removing ${_file}"; rm -rf "${_file}"; done
}

usage (){
    local _pacman_help=false

    local _wfa_usage
    _wfa_usage() {
        echo "Usage:"
        echo "${wfa_command}"
        echo "${wfa_command} <operation> [...]"
        echo
        echo "operations:"
        echo "    ${wfa_command} {-h --help}"
        echo "    ${wfa_command} {-A --vote}"
        echo "    ${wfa_command} {-V --version}"
       #echo "    ${wfa_command} {-D --database}    <options> <package(s)>"
       #echo "    ${wfa_command} {-F --files}       [options] [package(s)]"
        echo "    ${wfa_command} {-Q --query}       [options] [package(s)]"
        echo "    ${wfa_command} {-R --remove}      [options] <package(s)>"
        echo "    ${wfa_command} {-S --sync}        [options] [package(s)]"
       #echo "    ${wfa_command} {-T --deptest}     [options] [package(s)]"
       #echo "    ${wfa_command} {-U --upgrade}     [options] <file(s)>"
       #echo
       #echo "New operations:"
       #echo "    ${wfa_command} {-P --show}        [options]"
       #echo "    ${wfa_command} {-G --getpkgbuild} [package(s)]"
        echo
        echo "New options:"
        echo "       --repo             Assume targets are from the repositories"
        echo "    -a --aur              Assume targets are from the AUR"
        echo
        echo "Permanent configuration options:"
        echo "    --aururl      <url>   Set an alternative AUR URL"
        echo "    --makepkg     <file>  makepkg command to use"
        echo "    --mflags      <flags> Pass arguments to makepkg"
        echo "    --pacman      <file>  pacman command to use"
        echo "    --git         <file>  git command to use"
        echo "    --gitflags    <flags> Pass arguments to git"
        echo "    --gpg         <file>  gpg command to use"
        echo "    --gpgflags    <flags> Pass arguments to gpg"
        echo "    --config      <file>  pacman.conf file to use"
        echo "    --makepkgconf <file>  makepkg.conf file to use"
        echo "    --nomakepkgconf       Use the default makepkg.conf"
        echo
        echo "wfa specific options:"
        echo "    -c --clean            Remove unneeded dependencies"
        echo
        echo "This program is an alpha version that is not yet stable"
        echo "If you find a bug, please share it on GitHub"
        echo "https://github.com/hayao0819/wfa/issues"
        echo
    }

    local _wfa_usage_sync
    _wfa_usage_sync() {
        echo "usage:  ${wfa_command} {-S --sync} [options] [package(s)]"
        echo "options:"
        echo "  -b, --dbpath <path>  set an alternate database location"
        echo "  -c, --clean          remove old packages from cache directory (-cc for all)"
        echo "  -d, --nodeps         skip dependency version checks (-dd to skip all checks)"
        echo "  -s, --search <regex> search remote repositories for matching strings"
        echo "  -u, --sysupgrade     upgrade installed packages (-uu enables downgrades)"
        echo "  -y, --refresh        download fresh package databases from the server"
        echo "                       (-yy to force a refresh even if up to date)"
        echo "      --arch <arch>    set an alternate architecture"
        echo "      --color <when>   colorize the output"
        echo "      --config <path>  set an alternate configuration file"
        echo "      --confirm        always ask for confirmation"
        echo "      --debug          display debug messages"
        echo "      --disable-download-timeout"
        echo "                       use relaxed timeouts for download"
        echo "      --gpgdir <path>  set an alternate home directory for GnuPG"
        echo "      --hookdir <dir>  set an alternate hook location"
        echo "      --ignore <pkg>   ignore a package upgrade (can be used more than once)"
        echo "      --ignoregroup <grp>"
        echo "                       ignore a group upgrade (can be used more than once)"
        echo "      --noconfirm      do not ask for any confirmation"
    }

    local _wfa_usage_remove
    _wfa_usage_remove() {
        echo "usage:  ${wfa_command} {-R --remove} [options] <package(s)>"
        echo "options:"
        echo "  -b, --dbpath <path>  set an alternate database location"
        echo "  -d, --nodeps         skip dependency version checks (-dd to skip all checks)"
        echo "  -u, --unneeded       remove unneeded packages"
        echo "      --arch <arch>    set an alternate architecture"
        echo "      --color <when>   colorize the output"
        echo "      --config <path>  set an alternate configuration file"
        echo "      --confirm        always ask for confirmation"
        echo "      --debug          display debug messages"
        echo "      --disable-download-timeout"
        echo "                       use relaxed timeouts for download"
        echo "      --noconfirm      do not ask for any confirmation"
    }

    if [[ "${operation}" = "none" ]]; then
        _wfa_usage
    elif [[ "${_pacman_help}" = true ]]; then
        "${pacman_command}" -h --${operation}
    elif [[ "$(type -t "_wfa_usage_${operation}" )" = "function" ]]; then
        eval "_wfa_usage_${operation}"
    else
        msg_error "Help for this operation is not implemented"
        exit 1
    fi
}

set_operation() {
    if [[ "${operation}" = "none" ]]; then
        operation="${1}"
        add_args pacman "--${operation}"
    else
        msg_error "only one operation may be used at a time"
        exit 1
    fi
}

run_sudo() { (( ${UID} == 0 )) && eval "${@}" || eval "sudo" "${@}"; return 0; }

run_pacman() { run_sudo "${pacman_command}" "${@}"; }

wfa() { "${wfa_path}" "${@}"; }

# pacmanの引数を追加する
# https://github.com/FascodeNet/aptpac/blob/master/aptpac のADD_OPTION関数を参考
# Usage: add_args [pacman/makepkg/git/gpg/sudo/curl] <args1> <args2>...
add_args() {
    local _target="${1}" _args_array
    shift 1

    case "${_target}" in
        "makepkg")
            _args_array=(${makepkg_args})
            _args_array+=(${@})
            makepkg_args=${_args_array[@]}
            #msg_debug "makepkg ARGS: ${makepkg_args}"
            msg_debug "%s ARGS: " "makepkg" ${makepkg_args}
            ;;

        "pacman")
            _args_array=(${pacman_args})
            _args_array+=(${@})
            pacman_args=${_args_array[@]}
            #msg_debug "pacman ARGS: ${pacman_args}"
            msg_debug "%s ARGS: %s" "pacman" "${pacman_args}"
            ;;
        "git")
            _args_array=(${mpg_args})
            _args_array+=(${@})
            git_args=${_args_array[@]}
            msg_debug "git ARGS: ${git_args}"
            ;;
        "gpg")
            _args_array=(${gpg_args})
            _args_array+=(${@})
            gpg_args=${_args_array[@]}
            msg_debug "gpg ARGS: ${gpg_args}"
            ;;
        "sudo")
            _args_array=(${sudo_args})
            _args_array+=(${@})
            sudo_args=${_args_array[@]}
            msg_debug "sudo ARGS: ${sudo_args}"
            ;;
        "curl")
            _args_array=(${curl_args})
            _args_array+="${@}"
            curl_args=${_args_array[@]}
            msg_debug "curl ARGS: ${curl_args}"
            ;;
        *)
            msg_error "Failed to set the argument of %s" "${_target}"
            msg_error "Setting that command is not currently supported"
            exit 1
            ;;
    esac
}

# 引数で指定されたパッケージがAUR以外の場所に存在しない場合にのみ正常終了します(AURのパッケージの場合に正常終了)
check_repo_package() {
    # 参考: https://qiita.com/Hayao0819/items/a8740a17301fafa2fdab
    pacman -Ssq "${1}" 2>/dev/null | grep -o ".*${1}$" 1> /dev/null 2>&1 && return 0 || return 1;
}


# 引数で指定されたパッケージが既にインストールされている場合は正常終了します。
check_installed_package() { "${pacman_command}" -Qq "${1}" > /dev/null 2>&1 && return 0 || return 1; }

# この関数に渡されたオペレーションが実行中の場合のみ正常終了します。
check_operation() { [[ "${1}" = "${operation}" ]] && return 0 || return 1; }

# ~/.cacheに相当するディレクトリを返します
get_cache_dir() {
    local _user_config_dir _cache_dir
    if [[ -v XDG_CONFIG_HOME ]]; then
        _user_config_dir="${XDG_CONFIG_HOME}"
    else
        _use_config_dir="${HOME}/.config"
    fi
    if [[ -f "${_use_config_dir}/user-dirs.dirs" ]]; then
        source "${_use_config_dir}/user-dirs.dirs"
    fi
    if [[ -v XDG_CACHE_HOME ]]; then
        _cache_dir="${XDG_CACHE_HOME}"
    else
        _cache_dir="${HOME}/.cache"
    fi
    echo -n "${_cache_dir}"
}

# Usage: get_srcinfo_data <path> <var>
# 参考: https://qiita.com/withelmo/items/b0e1ffba639dd3ae18c0
get_srcinfo_data() {
    local _srcinfo="${1}" _ver="${2}"
    local _srcinfo_json=$(python << EOF
from srcinfo.parse import parse_srcinfo; import json
text = """
$(cat ${1})
"""
parsed, errors = parse_srcinfo(text)
print(json.dumps(parsed))
EOF
)
    echo "${_srcinfo_json}" | jq -rc "${2}" | tr '\n' ' '
}

get_aur_json() {
    local _package="${1}"
    local _aur_json=$("${curl_command}" ${curl_args} -sL "https://aur.archlinux.org/rpc/?v=5&type=search&by=name&arg=${_package}" | jq -r)
    if (( "$(echo "${_aur_json}" | jq -r ".resultcount")" != 0 )); then
        echo "${_aur_json}" | jq -r ".results[]"
    fi
}


# AURからパッケージをビルドしてインストールします
# 現在1つのパッケージしか指定できません
install_aur_package() {
    local _package="${1}"

    # Create cache dir
    if [[ ! -v wfa_cache_dir ]]; then
        wfa_cache_dir="$(get_cache_dir)/wfa"
    fi
    mkdir -p "${wfa_cache_dir}/archive"
    mkdir -p "${wfa_cache_dir}/build/${_package}"

    # AurJsonから値を取得
    msg_info "Searching in AUR ..."
    local _aur_json="$(get_aur_json "${_package}")"
    if [[ -z "${_aur_json}" ]]; then
        msg_error "Could not find all required packages: %s" "${_package}"
        exit 1
    fi
    local _found_packages="$(echo "${_aur_json}" | jq -r --tab '.Name')"
    #msg_debug "Found package: $(echo ${_found_packages} | tr '\n' ' ')"

    if [[ -n "$(echo "${_found_packages}" | grep -x "${_package}" )" ]]; then
        msg_debug "Select a package %s with an exact name match" "${_package}"
    else
        msg_error "No package with an exact name match was found"
        exit 1
    fi

    # PKGBUILDをダウンロード
    msg_info "Download PKGBUILD of %s" "${_package}"
    _aur_json=$(echo "${_aur_json}" | jq -r "select(.Name == \"${_package}\")" )
    local _aur_snapshot_url="${aururl%/}$(echo "${_aur_json}" | jq -r ".URLPath")"
    local _aur_version="$(echo "${_aur_json}" | jq -r ".Version")"
    local _aur_packagebase="$(echo "${_aur_json}" | jq -r ".PackageBase")"
    msg_debug "Get PKGBUILD from %s" "${_aur_snapshot_url}"

    local _pkgbuild_archive_path="${wfa_cache_dir}/archive/${_package}-${_aur_version}"
    local _download_pkgbuild=true
    if [[ -f "${_pkgbuild_archive_path}" ]]; then
        msg_warn "PKGBUILD has already been downloaded"
        msg_warn -n "Do you want to overwrite and download? [n] :"
        local _yes_or_no
        if [[ "${noconfirm}" = true ]]; then
            echo
            _yes_or_no="No"
        else
            read _yes_or_no
        fi
        case "${_yes_or_no}" in
            "y" | "Y" | "yes" | "Yes" | "YES" ) _download_pkgbuild=true  ;;
            *                                 ) _download_pkgbuild=false ;;
        esac
    fi
    if [[ "${_download_pkgbuild}" = true ]]; then
        remove "${_pkgbuild_archive_path}"
        "${curl_command}"  ${curl_args} -L -C - -f -o "${_pkgbuild_archive_path}" "${_aur_snapshot_url}"
    fi

    # PKGBUILDを展開
    msg_info "Unpacking the tarball of PKGBUILD ..."
    tar -xv -f "${_pkgbuild_archive_path}" -C "${wfa_cache_dir}/build/" > /dev/null 2>&1

    # .SRCINFOを解析
    local _build_dir="${wfa_cache_dir}/build/${_aur_packagebase}"
    if [[ ! -f "${_build_dir}/.SRCINFO" ]]; then
        msg_warn ".SRCINFO was not found.\nGenerating it using makepkg"
        (
            cd "${_build_dir}"
            "${makepkg_command}" --printsrcinfo > "${_build_dir}/.SRCINFO"
        )
    fi

    local _makedepends="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".makedepends[]?")"
    local _depends="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".depends[]?")"
    local _conflicts="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".conflicts[]?")"
    msg_debug "makedepends: %s" "${_makedepends}"
    msg_debug "depends: %s" "${_depends}"
    msg_debug "conflicts: %s " "${_conflicts}"


    # 衝突を確認
    local _pkg _conflicts_found=false
    for _pkg in ${_conflicts[@]} ${_package}; do
        if "${pacman_command}" -Qq "${_pkg}" > /dev/null 2>&1 && [[ ! "$("${pacman_command}" -Qq "${_pkg}" 2> /dev/null)" = "${_package}" ]]; then
            _conflicts_found=true
            msg_error "${_package} is colliding with $("${pacman_command}" -Qq "${_pkg}" 2> /dev/null)"
        fi
    done
    if [[ "${_conflicts_found}" = true ]]; then
        msg_error "Conflict(s) was found"
        exit 1
    fi


    # 依存パッケージをインストール
    if [[ "${nodeps}" = false ]]; then
        msg_info "Install dependent packages..."
        local _force_aur="${force_aur}"
        force_aur=false

        local __package
        local __install_list=()
        local __remove_list=()

        # dependsからインストールされていないパッケージをインストール
        for __package in "${_depends[@]}"; do
            if ! check_installed_package "${__package}"; then
                __install_list+=("${__package}")
            fi
        done

        # makedependsからインストールされていないパッケージをインストール
        for __package in "${_makedepends[@]}"; do
            if ! check_installed_package "${__package}"; then
                __install_list+=("${__package}")

                # もしdependsに含まれていないなら
                if [[ $(printf '%s\n' "${_depends[@]}" | grep -qx "${__package}"; echo -n ${?} ) -eq 0 ]]; then
                    __remove_list+=("${__package}")
                fi
            fi
        done


        install_package "${__install_list[*]}"
        force_aur="${_force_aur}"
        unset _force_aur
    fi

    # ビルド準備
    # srcdirの確認
    if [[ -d "${_build_dir}/src" ]]; then
        msg_info "Found %s" "${_build_dir}/src"
        msg_info -n "Packages to cleanBuild? [n] :"
        local _yes_or_no
        unset _yes_or_no
        if [[ "${noconfirm}" = true ]]; then
            echo
            _yes_or_no="No"
        else
            read _yes_or_no
        fi
        case "${_yes_or_no}" in
            "y" | "Y" | "yes" | "Yes" | "YES" ) add_args makepkg "--clean" ;;
        esac
    fi


    # ビルド
    add_args "makepkg" "-sf"
    (
        cd "${_build_dir}"
        "${makepkg_command}" "${makepkg_args}"
    )


    # ビルド後のパッケージ一覧を生成
    (
        cd "${_build_dir}"
        "${makepkg_command}" --printsrcinfo > "${_build_dir}/.SRCINFO"
    )
    local _pkgnames=($(get_srcinfo_data "${_build_dir}/.SRCINFO" ".packages | keys[]"))
    local _pkgver="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".pkgver" | sed 's/ //g')"
    local _pkgrel="$(get_srcinfo_data "${_build_dir}/.SRCINFO" ".pkgrel" | sed 's/ //g')"
    local _arch_array=($(get_srcinfo_data "${_build_dir}/.SRCINFO" ".arch[]"))
    local _arch _pkgname
    if [[ "${_arch_array[*]}" = "any" ]]; then
        _arch="any"
    else
        _arch="${arch}"
    fi
    local _PKGEXT=$(
        source "${makepkg_config}"
        echo "${PKGEXT}"
    )
    local _pkgfilelist=()
    
    #for _pkgname in ${_pkgnames[@]}; do
    #    _pkgfilelist+=("${_build_dir}/${_pkgname}-${_pkgver}-${_pkgrel}-${_arch}${_PKGEXT}")
    #done

    _pkgfilelist+=("${_build_dir}/${_package}-${_pkgver}-${_pkgrel}-${_arch}${_PKGEXT}")

    # インストール
    run_pacman -U --noconfirm "${_pkgfilelist[@]}"


    # ビルド後に不要なパッケージを削除
    if (( "${#__remove_list[@]}" != 0 )); then
        wfa -Rsnc --noconfirm "${__remove_list[*]}"
    fi
}

# AURのパッケージを検索
search_aur_package() {
    local _package="${1}"
    local _aur_json="$(get_aur_json "${_package}")"
    if [[ -z "${_aur_json}" ]]; then
        msg_error "Could not find all required packages: %s" "${_package}"
        exit 1
    fi
    local _found_pkgname=($(echo "${_aur_json}" | jq -r ".Name" ))

    if [[ "${quiet}" = true ]]; then
        local _IFS="${IFS}"
        IFS=$'\n'
        echo "${_found_pkgname[*]}"
        IFS="${_IFS}"
    else
        local  _found_package __pkgver __popularity __vote __pkgdesc __orphaned __installed __output_text=()
        for _found_package in ${_found_pkgname[@]}; do
            __orphaned=false
            __installed=false
            _found_json="$(echo ${_aur_json} | jq "select(.Name == \"${_found_package}\")")"

            #echo "${_found_json}"
            __pkgver="$(echo "${_found_json}" | jq -r ".Version" )"
            __popularity="$(echo "${_found_json}" | jq -r ".Popularity" )"
            __vote="$(echo "${_found_json}" | jq -r ".NumVotes" )"
            __pkgdesc="$(echo "${_found_json}" | jq -r ".Description" )"

            # 人気度の少数2位以下を四捨五入
            # 参考: http://www.rivhiro-weather.com/knowledge/?p=536
            msg_debug "Raw popularity: %s" "${__popularity}"
            __popularity="$(printf "%g\n" "${__popularity}" | awk '{printf("%4.2f", $1)}')"

            # 孤児判定
            #参考: https://www.366service.com/jp/qa/7c95f46e5236039134ff5b862ae2cd13
            if ! echo "${_found_json}" | jq -r --exit-status ".Maintainer" 1> /dev/null 2> /dev/null ; then
                __orphaned=true
            fi

            # インストール済み判定
            if check_installed_package "${_found_package}"; then
                __installed=true
            fi

            __output_text+=(
                "$(text -n -c blue -b "aur")/$(text -n -b "${_found_package}") $(text -n -c cyan "${__pkgver}") (+$(text -n -b "${__vote} ${__popularity}"))"
            )
            
            if [[ "${__orphaned}" = true ]]; then
                __output_text+=("$(text -bc red "(Orphaned)")")
            fi

            if [[ "${__installed}" = true ]]; then
                __output_text+=("$(text -bc cyan "[Installed]")")
            fi
            echo "${__output_text[*]}"
            echo "    ${__pkgdesc}"
            unset __pkgver __popularity __vote __pkgdesc _found_json __orphaned __installed __output_text
        done
    fi
}

# バージョンを表示して終了
operation_version() {
    # Pyalpmからlibalpmの値を取得
    # 参考: https://pyalpm.readthedocs.io/en/latest/pyalpm/pyalpm.html
    local _libalpm_version="$(python3 -c 'import pyalpm; print(pyalpm.alpmversion())')"
    local _pacman_version="$("${pacman_command}" -Q pacman | cut -d ' ' -f 2)"
    echo "wfa v${wfa_version} - pacman v${_pacman_version} - libalpm v${_libalpm_version}"
}

operation_remove() {
    local _package _not_found=false
    for _package in ${specified_packages[@]}; do
        if ! check_installed_package "${_package}"; then
            msg_error "target not found: %s" "${_package}"
            _not_found=true
        fi
    done
    if [[ "${_not_found}" = true ]]; then
        exit 1
    else
        run_pacman ${pacman_args} "${specified_packages[@]}"
    fi
}

# Usage: install_package <package1> <package2>...
install_package() {
    local _package _repo_packages=() _aur_packages=()
    for _package in ${@}; do
        if ! check_installed_package "${_package}"; then
            if check_repo_package "${_package}"; then
                # 公式パッケージなのでpacmanでそのままインストール
                _repo_packages+=("${_package}")
            else
                # AUR上のパッケージの場合の処理
                _aur_packages+=("${_package}")
            fi
        fi
    done

    if (( "${#_repo_packages[@]}" > 0 )); then
        run_pacman --asdeps ${pacman_args} "${_repo_packages[@]}"
    fi

    if (( "${#_aur_packages[@]}" > 0 )); then
        unset _package
        for _package in ${_aur_packages[@]}; do
            install_aur_package "${_package}"
        done
    fi
}

upgrade_aur_package() {
    #ここまで翻訳
    msg_error "This is a feature that has not been implemented yet"
}

operation_sync(){
    local _package
    if (( "${sync_clean_count}" >= 1 )); then
        remove "$(get_cache_dir)/wfa"
        run_pacman ${pacman_args} $(
            local _count
            for _count in $(seq 1 ${sync_clean_count}); do
                echo -n "-c "
            done
        )
    fi


    if [[ "${sync_search}" = true ]]; then
        for _package in ${specified_packages[@]}; do
            search_aur_package "${_package}"
        done
        "${pacman_command}" ${pacman_args} ${specified_packages[@]} || :
    else
        if [[ "${sync_upgrade}" = true ]]; then
            upgrade_aur_package
            run_pacman ${pacman_args} --sysupgrade
        fi
        for _package in ${specified_packages[@]}; do
            if check_repo_package "${_package}" && [[ "${force_aur}" = false ]]; then
                # 公式パッケージなのでpacmanでそのままインストール
                run_pacman ${pacman_args} "${_package}"
            else
                # AUR上のパッケージの場合の処理
                install_aur_package "${_package}"
                #msg_error "Getting the AUR package has not been implemented yet."
                #exit 1
            fi
        done
    fi
}


operation_vote() {

    # aurvoteの確認
    if ! type aurvote 1> /dev/null 2> /dev/null; then
        msg_error "There is no aurvote"
        msg_error "Please install with %s" "\"wfa -S aurvote\""
        exit 1
    fi

    local _package _aur_json _found_result_count _pkgver _before_popularity _before_vote
    for _package in ${specified_packages[@]}; do

        # 存在するパッケージか確認
        local _aur_json="$(get_aur_json "${_package}")"
        if [[ -z "${_aur_json}" ]]; then
            msg_error "Could not find all required packages: %s" "${_package}"
            exit 1
        fi
        _aur_json=$(echo "${_aur_json}" | jq -r "select(.Name == \"${_package}\")")

        # jsonから値を取り出して整形
        msg_info "Searching in AUR ..."
        _pkgver="$(echo "${_aur_json}" | jq -r ".Version" )"
        _before_popularity="$(printf "%g\n" "$(echo "${_aur_json}" | jq -r ".Popularity" )" | awk '{printf("%4.2f", $1)}')"
        _before_vote="$(echo "${_aur_json}" | jq -r ".NumVotes" )"

        # 投票を操作
        if [[ "$(aurvote --check "${_package}")" = "not voted" ]]; then
            msg_info "Voted for %s" "${_package}"
            aurvote --vote "${_package}" 1> /dev/null
        else
            msg_info "Unvoted for %s" "${_package}"
            aurvote --unvote "${_package}" 1> /dev/null
        fi

        # 投票後の値を取得
        msg_info "Getting post-voting information ..."
        _aur_json=$(get_aur_json "${_package}" | jq -r "select(.Name == \"${_package}\")")
        _after_popularity="$(printf "%g\n" "$(echo "${_aur_json}" | jq -r ".Popularity" )" | awk '{printf("%4.2f", $1)}')"
        _after_vote="$(echo "${_aur_json}" | jq -r ".NumVotes" )"

        # 結果を出力
        msg_info "%s %s (+%s) → (+%s)" "$(text -nb "${_package}")" "$(text -nc cyan "${_pkgver}")" "$(text -nb "${_before_vote} ${_before_popularity}")" "$(text -nb "${_after_vote} ${_after_popularity}")"
    done
}

unavailable_in_this_operation() {
    msg_error "This option is not available in the current operation"
    exit 1
}

# オペレーションを実行します
run_operation() {
    local _operation="${1}"
    msg_debug "Operation: %s" "${_operation}"
    if [[ "${quiet}" = false ]]; then
        msg_warn "This program is an alpha version that is not yet stable\nIf you find a bug, please share it on GitHub\nhttps://github.com/hayao0819/wfa/issues"
    fi

    eval "operation_${_operation}"
}

# Parse options
ARGUMENT="${@}"
_opt_short="AQRShVdb:aysucqn"
_opt_long="query,remove,sync,help,version,debug,dbpath:,aururl,aur,noconfirm,config:,makepkg:,mflags:,pacman:,git:,gitflags:,gpg:,gpgflags:,makepkgconf:,nomakepkgconf,nodeps,refresh,bash-debug,msg-debug,sysupgrade,color:,nocolor,clean,quiet,arch:,confirm,disable-download-timeout,curl:,curlflags:,unneeded,puella,wfa-debug,cascade,ignoregroup:,ignore:,hookdir:,gpgdir:"

OPT=$(getopt -o ${_opt_short} -l ${_opt_long} -- ${ARGUMENT})
[[ ${?} != 0 ]] && exit 1
unset _opt_short _opt_long

eval set -- "${OPT}"
msg_debug "Argument: ${OPT}"

while true; do
    case "${1}" in
        -A | --vote)
            set_operation "vote"
            shift 1
            ;;
        -Q | --query)
            set_operation "query"
            shift 1
            ;;
        -R | --remove)
            set_operation "remove"
            shift 1
            ;;
        -S | --sync)
            set_operation "sync"
            shift 1
            ;;
        -V | --version)
            set_operation "version"
            shift 1
            ;;
        --)
            shift
            break
            ;;
        *)
            shift 1
            ;;
    esac
done

eval set -- "${OPT}"

while true; do
    case "${1}" in
        -a | --aur)
            force_aur=true
            msg_debug "Assume targets are from the AUR"
            shift 1
            ;;
        --debug)
            debug=true
            add_args pacman "--debug"
            shift 1
            ;;
        -d | --nodeps)
            nodeps=true
            add_args pacman "--nodeps"
            shift 1
            ;;
        -b | --dbpath)
            add_args pacman "--dbpath '${2}'"
            shift 2
            ;;
        -y | --refresh)
            option_y_count=$(( option_y_count + 1 ))
            shift 1
            ;;
        -s | --search | --recursive)
            case "${1}" in
                --search)
                    #if [[ "${operation}" = "sync" ]]; then
                    if check_operation "sync"; then
                        add_args pacman "--search"
                        sync_search=true
                    else
                        unavailable_in_this_operation
                    fi
                    ;;
                --recursive)
                    #if [[ "${operation}" = "remove" ]]; then
                    if check_operation "rmeove"; then
                        add_args pacman "--recursive"
                    else
                        unavailable_in_this_operation
                    fi
                    ;;
                -s)
                    case "${operation}" in
                        "sync")
                            add_args pacman "--search"
                            sync_search=true
                            ;;
                        "remove")
                            add_args pacman "--recursive"
                            ;;
                        *)
                            unavailable_in_this_operation
                            ;;
                    esac
                    ;;
            esac
            shift 1
            ;;
        -u | --sysupgrade | --unneeded)
            case "${1}" in
                --sysupgrade)
                    #if [[ "${operation}" = "sync" ]]; then
                    if check_operation "sync"; then
                        sync_upgrade=true
                    else
                        unavailable_in_this_operation
                    fi
                    ;;
                --unneeded)
                    #if [[ "${operation}" = "remove" ]]; then
                    if check_operation "rmeove"; then
                        add_args pacman "--unneeded"
                    else
                        unavailable_in_this_operation
                    fi
                    ;;
                -u)
                    case "${operation}" in
                        "sync")
                            sync_upgrade=true
                            ;;
                        "remove")
                            add_args pacman "--unneeded"
                            ;;
                        "none")
                            :
                            ;;
                        *)
                            unavailable_in_this_operation
                            ;;
                    esac
                    ;;
            esac
            shift 1
            ;;
        -c | --clean | --cascade)
            case "${1}" in
                --clean)
                    #if [[ "${operation}" = "sync" ]]; then
                    if check_operation "sync"; then
                        sync_clean_count=$(( sync_clean_count + 1 ))
                    else
                        unavailable_in_this_operation
                    fi
                    ;;
                --cascade)
                    #if [[ "${operation}" = "remove" ]]; then
                    if check_operation "rmeove"; then
                        add_args pacman "--cascade"
                    else
                        unavailable_in_this_operation
                    fi
                    ;;
                -c)
                    case "${operation}" in
                        "sync")
                            sync_clean_count=$(( sync_clean_count + 1 ))
                            ;;
                        "remove")
                            add_args pacman "--cascade"
                            ;;
                        *)
                            unavailable_in_this_operation
                            ;;
                    esac
                    ;;
            esac
            shift 1
            ;;
        -q | --quiet)
            quiet=true
            add_args pacman "--quiet"
            shift 1
            ;;
        -n | --nosave)
            add_args pacman "--nosave"
            shift 1
            ;;
        --arch)
            arch="${2}"
            add_args pacman "--arch ${2}"
            shift 2
            ;;
        --aururl)
            aururl="${2}"
            shift 2
            ;;
        --noconfirm)
            add_args pacman "--noconfirm"
            noconfirm=true
            shift 1
            ;;
        --config)
            pacman_config="${2}"
            add_args pacman "--config ${2}"
            shift 2
            ;;
        --makepkg)
            makepkg_command="${2}"
            shift 2
            ;;
        --mflags)
            #makepkg_args="${2}"
            add_args makepkg "${2}"
            shift 2
            ;;
        --pacman)
            pacman_command="${2}"
            shift 2
            ;;
        --git)
            git_command="${2}"
            shift 2
            ;;
        --gitflags)
            #git_args="${2}"
            add_args git "${2}"
            shift 2
            ;;
        --makepkgconfig)
            if [[ "${nomakepkgconf}" = false ]]; then
                makepkg_config="${2}"
            else
                msg_warn "--nomakepkgconf is specified.\n--makepkgconf has been ignored."
            fi
            shift 2
            ;;
        --nomakepkgconf)
            makepkg_config="/etc/makepkg.conf"
            nomakepkgconf=true
            shift 1
        ;;
        --bash-debug)
            bash_debug=true
            set -xv
            shift 1
            ;;
        --msg-debug)
            msgdebug=true
            shift 1
            ;;
        --color)
            case "${2}" in
                "never")
                    nocolor=true
                    add_args pacman "--color never"
                    ;;
                "always")
                    nocolor=false
                    add_args pacman "--color always"
                    ;;
                "auto")
                    msg_error "auto is not currently supported."
                    add_args pacman "--color auto"
                    ;;
            esac
            ;;
        --nocolor)
            nocolor=true
            add_args pacman "--color never"
            shift 1
            ;;
        --confirm)
            noconfirm=false
            shift 1
            ;;
        --disable-download-timeout)
            add_args curl "--max-time 0"
            add_args pacman "--disable-download-timeout"
            shift 1
            ;;
        --curl)
            curl_command="${2}"
            shift 2
            ;;
        --curlflags)
            add_args curl "${2}"
            shift 2
            ;;
        --puella)
            text -flb "Please make a contract with me and become a Puella Magi !"
            echo
            shift 1
            exit 0
            ;;
        --wfa-debug)
            debug=true
            shift 1
            ;;
        --ignoregroup)
            add_args pacman "--ignoregroup ${2}"
            shift 2
            ;;
        --ignore)
            add_args pacman "--ignore ${2}"
            shift 2
            ;;
        --gpgdir)
            add_args pacman "--gpgdir ${2}"
            shift 2
            ;;
        --hookdir)
            add_args pacman "--hookdir ${2}"
            shift 2
            ;;
        -h | --help)
            usage
            shift 1
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            shift 1
            ;;
    esac
done

specified_packages=("${@}")

# Run database update
if (( "${option_y_count}" == 1 )); then
    run_pacman -Sy
elif (( "${option_y_count}" >= 2 )); then
    run_pacman -Syy
fi

# set_operationで設定された操作を実行
case "${operation}" in
    "version" | "sync" | "remove" | "vote")
        run_operation "${operation}"
        ;;
    "none")
        exit 0
        ;;
    *)
        msg_error "Undefined operation"
        exit 1
        ;;
esac
